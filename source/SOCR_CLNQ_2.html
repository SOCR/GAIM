<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>SOCR CLNQ Gen-2B: Optimized ML Clinical Decision Support</title>
    <link rel="icon" type="image/png" href="SOCR_Logo.png">
    
    <!-- TensorFlow.js -->
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@4.15.0/dist/tf.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs-backend-webgl@4.15.0/dist/tf-backend-webgl.min.js"></script>
    
    <!-- Universal Sentence Encoder -->
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow-models/universal-sentence-encoder@1.3.3/dist/universal-sentence-encoder.min.js"></script>
    
    <!-- Add Pako for older browser compatibility -->
	<script src="https://cdnjs.cloudflare.com/ajax/libs/pako/2.1.0/pako.min.js"></script>

    <!-- React -->
    <script src="https://unpkg.com/react@18/umd/react.development.js"></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    
    <!-- Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    
    <style>
        .lucide { width: 1rem; height: 1rem; stroke: currentColor; stroke-width: 2; fill: none; }
        .loading-spinner {
            border: 3px solid #f3f3f3;
            border-top: 3px solid #3498db;
            border-radius: 50%;
            width: 20px;
            height: 20px;
            animation: spin 1s linear infinite;
        }
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        .gpu-indicator {
            background: linear-gradient(45deg, #4ade80, #22c55e);
            animation: pulse 2s infinite;
        }
        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.7; }
        }
        .embedding-status {
            background: linear-gradient(45deg, #8b5cf6, #a855f7);
            animation: glow 3s ease-in-out infinite alternate;
        }
        @keyframes glow {
            from { box-shadow: 0 0 5px #8b5cf6; }
            to { box-shadow: 0 0 20px #a855f7; }
        }
    </style>
</head>
<body>
    <div id="root"></div>
    
    <script type="text/babel">
        // Icons
        const AlertCircle = () => <svg className="lucide"><circle cx="12" cy="12" r="10"/><line x1="12" y1="8" x2="12" y2="12"/><line x1="12" y1="16" x2="12.01" y2="16"/></svg>;
        const Activity = () => <svg className="lucide"><polyline points="22,12 18,12 15,21 9,3 6,12 2,12"/></svg>;
        const TrendingUp = () => <svg className="lucide"><polyline points="23,6 13.5,15.5 8.5,10.5 1,18"/><polyline points="17,6 23,6 23,12"/></svg>;
        const DollarSign = () => <svg className="lucide"><line x1="12" y1="1" x2="12" y2="23"/><path d="M17 5H9.5a3.5 3.5 0 0 0 0 7h5a3.5 3.5 0 0 1 0 7H6"/></svg>;
        const Brain = () => <svg className="lucide"><path d="M9.5 2A2.5 2.5 0 0 1 12 4.5v15a2.5 2.5 0 0 1-4.96.44 2.5 2.5 0 0 1-2.96-3.08 3 3 0 0 1-.34-5.58 2.5 2.5 0 0 1 1.32-4.24 2.5 2.5 0 0 1 1.98-3A2.5 2.5 0 0 1 9.5 2Z"/></svg>;
        const Heart = () => <svg className="lucide"><path d="M20.84 4.61a5.5 5.5 0 0 0-7.78 0L12 5.67l-1.06-1.06a5.5 5.5 0 0 0-7.78 7.78l1.06 1.06L12 21.23l7.78-7.78 1.06-1.06a5.5 5.5 0 0 0 0-7.78z"/></svg>;
        const Users = () => <svg className="lucide"><path d="M16 21v-2a4 4 0 0 0-4-4H6a4 4 0 0 0-4 4v2"/><circle cx="9" cy="7" r="4"/></svg>;
        const Clock = () => <svg className="lucide"><circle cx="12" cy="12" r="10"/><polyline points="12,6 12,12 16,14"/></svg>;
        const Thermometer = () => <svg className="lucide"><path d="M14 4v10.54a4 4 0 1 1-4 0V4a2 2 0 0 1 4 0Z"/></svg>;
        const Database = () => <svg className="lucide"><ellipse cx="12" cy="5" rx="9" ry="3"/><path d="M3 5v14a9 3 0 0 0 18 0V5"/><path d="M3 12a9 3 0 0 0 18 0"/></svg>;
        const Download = () => <svg className="lucide"><path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"/><polyline points="7,10 12,15 17,10"/><line x1="12" y1="15" x2="12" y2="3"/></svg>;
        const Play = () => <svg className="lucide"><polygon points="5,3 19,12 5,21"/></svg>;
        const Pause = () => <svg className="lucide"><rect x="6" y="4" width="4" height="16"/><rect x="14" y="4" width="4" height="16"/></svg>;
        const ChevronDown = () => <svg className="lucide"><polyline points="6,9 12,15 18,9"/></svg>;
        const ChevronRight = () => <svg className="lucide"><polyline points="9,18 15,12 9,6"/></svg>;
        const Cpu = () => <svg className="lucide"><rect x="4" y="4" width="16" height="16" rx="2"/><rect x="9" y="9" width="6" height="6"/><line x1="9" y1="1" x2="9" y2="4"/><line x1="15" y1="1" x2="15" y2="4"/><line x1="9" y1="20" x2="9" y2="23"/><line x1="15" y1="20" x2="15" y2="23"/><line x1="20" y1="9" x2="23" y2="9"/><line x1="20" y1="14" x2="23" y2="14"/><line x1="1" y1="9" x2="4" y2="9"/><line x1="1" y1="14" x2="4" y2="14"/></svg>;
        const Zap = () => <svg className="lucide"><polygon points="13,2 3,14 12,14 11,22 21,10 12,10 13,2"/></svg>;
        const CloudDownload = () => <svg className="lucide"><path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"/><polyline points="7,10 12,15 17,10"/><line x1="12" y1="15" x2="12" y2="3"/><circle cx="12" cy="2" r="3"/></svg>;
        const Layers = () => <svg className="lucide"><polygon points="12,2 2,7 12,12 22,7 12,2"/><polyline points="2,17 12,22 22,17"/><polyline points="2,12 12,17 22,12"/></svg>;
        const Save = () => <svg className="lucide"><path d="M19 21H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h11l5 5v11a2 2 0 0 1-2 2z"/><polyline points="17 21 17 13 7 13 7 21"/><polyline points="7 3 7 8 15 8"/></svg>;

        // Optimized ML Clinical Engine with Pre-computed Embeddings
        class OptimizedMLClinicalEngine {
            constructor() {
                this.isReady = false;
                this.useModel = null;
                this.precomputedEmbeddings = null;
                this.hpoData = null;
                this.biomedicalKB = null;
                this.embeddingsTensor = null;
				this.normalizedEmbeddingsTensor = null;  // Add this line
        		this.embeddingIndex = null;              // Add this line
        		this.categoryIndices = null;             // Add this line
				// Add to OptimizedMLClinicalEngine constructor
				this.performanceMetrics = {
				    loadTime: 0,
				    searchTimes: [],
				    memoryUsage: [],
				    cacheHitRate: 0
				};
                this.initialize();
            }

            async initialize() {
                try {
                    console.log('ðŸš€ Initializing Optimized ML Clinical Engine...');
                    
                    // Initialize WebGL backend
                    await this.initializeWebGLBackend();
                    
                    // Load Universal Sentence Encoder (only for user input)
                    await this.loadUniversalSentenceEncoder();
                    
                    // Load pre-computed embeddings
                    await this.loadPrecomputedEmbeddings();
                    
                    // Load basic knowledge bases (for fallback)
                    await this.loadBasicKnowledgeBases();
                    
                    this.isReady = true;
                    console.log('âœ… Optimized ML Clinical Engine ready!');
                    
                } catch (error) {
                    console.warn('âš ï¸ Falling back to basic mode:', error);
                    await this.initializeFallbackMode();
                    this.isReady = true;
                }
            }

            async initializeWebGLBackend() {
                await tf.setBackend('webgl');
                tf.env().set('WEBGL_FORCE_F16_TEXTURES', true);
                tf.env().set('WEBGL_PACK', true);
                console.log('ðŸŽ® WebGL backend initialized:', tf.getBackend());
                console.log('ðŸ’¾ Memory info:', tf.memory());
            }

            async loadUniversalSentenceEncoder() {
                console.log('ðŸ§  Loading Universal Sentence Encoder...');
                this.useModel = await use.load();
                console.log('âœ… Universal Sentence Encoder loaded');
            }

updateLoadingStatus(status) {
    console.log(`ðŸ“Š ${status}`);
    const event = new CustomEvent('embeddings-loading-progress', {
        detail: { status }
    });
    window.dispatchEvent(event);
}


// Enhanced loadPrecomputedEmbeddings method with compression support
// Robust embedding loader with multiple fallback strategies
async loadPrecomputedEmbeddings() {
    console.log('ðŸ“¥ Loading pre-computed clinical embeddings...');
    
    // Prioritize uncompressed files for reliability, compressed as secondary option
    const embeddingSources = [
        // Primary: Uncompressed files (most reliable)
        {
            url: 'assets/clinical-embeddings-multicore-2025-06-26.json',
            compressed: false,
            type: 'local_uncompressed',
            priority: 1
        },
        {
            url: 'https://your-supabase-url.supabase.co/storage/v1/object/public/embeddings/clinical-embeddings-multicore-2025-06-26.json',
            compressed: false,
            type: 'supabase_uncompressed',
            priority: 2
        },
        
        // Secondary: Compressed files (if uncompressed fails)
        {
            url: 'assets/clinical-embeddings-multicore-2025-06-26.json.gz',
            compressed: true,
            type: 'local_compressed',
            priority: 3
        },
        {
            url: 'https://your-supabase-url.supabase.co/storage/v1/object/public/embeddings/clinical-embeddings-multicore-2025-06-26.json.gz',
            compressed: true,
            type: 'supabase_compressed',
            priority: 4
        }
    ];

    // Sort by priority
    embeddingSources.sort((a, b) => a.priority - b.priority);

    for (const source of embeddingSources) {
        try {
            console.log(`ðŸ” Trying to load embeddings from: ${source.url} (${source.compressed ? 'compressed' : 'uncompressed'})`);
            
            const result = await this.loadFromSource(source);
            if (result) {
                console.log(`âœ… Successfully loaded embeddings from ${source.type}`);
                return;
            }
            
        } catch (error) {
            console.log(`âŒ Failed to load from ${source.url}:`, error.message);
            // Continue to next source
        }
    }
    
    // If all sources fail, use fallback
    console.log('âš ï¸ All embedding sources failed, using fallback mode');
    this.createFallbackEmbeddings();
}

async loadFromSource(source) {
    const startTime = performance.now();
    
    // Set timeout for the entire loading process
    const timeoutMs = source.compressed ? 60000 : 30000; // Longer timeout for compressed files
    
    const controller = new AbortController();
    const timeoutId = setTimeout(() => {
        controller.abort();
        console.log(`â° Timeout loading from ${source.url} after ${timeoutMs/1000}s`);
    }, timeoutMs);
    
    try {
        const response = await fetch(source.url, {
            signal: controller.signal,
            headers: {
                'Cache-Control': 'no-cache'
            }
        });
        
        if (!response.ok) {
            throw new Error(`HTTP ${response.status}: ${response.statusText}`);
        }
        
        console.log(`ðŸ“Š Response size: ${(response.headers.get('content-length') || 'unknown')} bytes`);
        
        let embeddingData;
        
        if (source.compressed) {
            embeddingData = await this.handleCompressedData(response, source);
        } else {
            embeddingData = await this.handleUncompressedData(response, source);
        }
        
        if (!embeddingData) {
            throw new Error('Failed to parse embedding data');
        }
        
        // Validate and process the data
        if (this.validateEmbeddingData(embeddingData)) {
            await this.processEmbeddingData(embeddingData, source);
            
            const loadTime = performance.now() - startTime;
            console.log(`âš¡ Loading completed in ${(loadTime / 1000).toFixed(2)}s`);
            
            clearTimeout(timeoutId);
            return true;
        } else {
            throw new Error('Invalid embedding data structure');
        }
        
    } catch (error) {
        clearTimeout(timeoutId);
        if (error.name === 'AbortError') {
            throw new Error(`Loading timeout after ${timeoutMs/1000}s`);
        }
        throw error;
    }
}

async handleUncompressedData(response, source) {
    console.log('ðŸ“„ Processing uncompressed JSON data...');
    
    try {
        // For large files, we might want to process in chunks
        if (response.headers.get('content-length') > 100 * 1024 * 1024) { // > 100MB
            console.log('ðŸ“Š Large file detected, using streaming parser...');
            return await this.streamParseJSON(response);
        } else {
            return await response.json();
        }
    } catch (error) {
        console.log(`âŒ JSON parsing failed: ${error.message}`);
        throw error;
    }
}

async handleCompressedData(response, source) {
    console.log('ðŸ“¦ Processing compressed data...');
    
    try {
        const compressedData = await response.arrayBuffer();
        console.log(`ðŸ“Š Compressed size: ${(compressedData.byteLength / 1024 / 1024).toFixed(1)}MB`);
        
        // Try browser native decompression first (fastest)
        if ('DecompressionStream' in window) {
            return await this.decompressWithNativeAPI(compressedData);
        }
        // Fallback to pako library
        else if (typeof pako !== 'undefined') {
            return await this.decompressWithPako(compressedData);
        }
        // If no decompression available, throw error to try next source
        else {
            throw new Error('No decompression method available');
        }
        
    } catch (error) {
        console.log(`âŒ Decompression failed: ${error.message}`);
        throw error;
    }
}

async decompressWithNativeAPI(compressedData) {
    console.log('ðŸ”§ Using browser native DecompressionStream...');
    
    return new Promise(async (resolve, reject) => {
        try {
            const stream = new DecompressionStream('gzip');
            const writer = stream.writable.getWriter();
            const reader = stream.readable.getReader();
            
            // Start writing compressed data in chunks to avoid blocking
            const chunkSize = 1024 * 1024; // 1MB chunks
            let offset = 0;
            
            const writeChunks = async () => {
                while (offset < compressedData.byteLength) {
                    const chunk = compressedData.slice(offset, offset + chunkSize);
                    await writer.write(new Uint8Array(chunk));
                    offset += chunkSize;
                    
                    // Yield control to prevent blocking
                    if (offset % (chunkSize * 10) === 0) {
                        await new Promise(resolve => setTimeout(resolve, 10));
                        console.log(`ðŸ“Š Decompression progress: ${(offset / compressedData.byteLength * 100).toFixed(1)}%`);
                    }
                }
                await writer.close();
            };
            
            // Start writing in the background
            writeChunks().catch(reject);
            
            // Read decompressed data
            const chunks = [];
            let totalSize = 0;
            
            while (true) {
                const { value, done } = await reader.read();
                if (done) break;
                
                chunks.push(value);
                totalSize += value.length;
                
                // Progress update
                if (chunks.length % 100 === 0) {
                    console.log(`ðŸ“Š Read ${(totalSize / 1024 / 1024).toFixed(1)}MB decompressed data...`);
                    // Yield control
                    await new Promise(resolve => setTimeout(resolve, 1));
                }
            }
            
            // Combine chunks
            console.log('ðŸ”„ Combining decompressed chunks...');
            const combined = new Uint8Array(totalSize);
            let position = 0;
            
            for (const chunk of chunks) {
                combined.set(chunk, position);
                position += chunk.length;
            }
            
            // Convert to text and parse JSON
            console.log('ðŸ”„ Converting to text and parsing JSON...');
            const decompressedText = new TextDecoder().decode(combined);
            
            // Parse JSON in chunks to avoid blocking
            const embeddingData = await this.parseJSONAsync(decompressedText);
            resolve(embeddingData);
            
        } catch (error) {
            reject(error);
        }
    });
}

async decompressWithPako(compressedData) {
    console.log('ðŸ”§ Using pako library for decompression...');
    
    return new Promise((resolve, reject) => {
        try {
            // Use setTimeout to make it non-blocking
            setTimeout(() => {
                try {
                    console.log('ðŸ“¦ Starting pako decompression...');
                    const decompressed = pako.ungzip(new Uint8Array(compressedData), { to: 'string' });
                    console.log(`ðŸ“Š Decompressed to ${(decompressed.length / 1024 / 1024).toFixed(1)}MB text`);
                    
                    // Parse JSON asynchronously
                    this.parseJSONAsync(decompressed).then(resolve).catch(reject);
                } catch (error) {
                    reject(new Error(`Pako decompression failed: ${error.message}`));
                }
            }, 10);
        } catch (error) {
            reject(error);
        }
    });
}

async parseJSONAsync(jsonString) {
    return new Promise((resolve, reject) => {
        // Use setTimeout to make JSON parsing non-blocking
        setTimeout(() => {
            try {
                console.log('ðŸ”„ Parsing JSON...');
                const data = JSON.parse(jsonString);
                console.log('âœ… JSON parsing complete');
                resolve(data);
            } catch (error) {
                reject(new Error(`JSON parsing failed: ${error.message}`));
            }
        }, 10);
    });
}

async streamParseJSON(response) {
    console.log('ðŸŒŠ Using streaming JSON parser for large file...');
    
    // Simple streaming approach - read response as text
    const text = await response.text();
    return await this.parseJSONAsync(text);
}

async processEmbeddingData(embeddingData, source) {
    this.updateLoadingStatus('Processing embedding data...');
    
	console.log('ðŸ”„ Processing embedding data...');
    
    this.precomputedEmbeddings = embeddingData;
    
    // Convert embeddings to TensorFlow tensor with chunking for large datasets
    const embeddings = embeddingData.embeddings;
    console.log(`ðŸ§® Converting ${embeddings.length} embeddings to TensorFlow tensor...`);
    
    if (embeddings.length > 10000) {
        // For large datasets, process in batches to avoid memory issues
        console.log('ðŸ“Š Large dataset detected, using batched tensor creation...');
        await this.createTensorInBatches(embeddings);
    } else {
        this.embeddingsTensor = tf.tensor2d(embeddings);
    }
    
    // Additional optimizations
    await this.optimizeEmbeddingStorage(embeddingData);
    
    console.log(`ðŸ“Š Loaded ${embeddingData.embeddings.length} embeddings`);
    console.log(`ðŸ”¢ Embedding dimension: ${embeddingData.metadata?.embeddingDimension || 'unknown'}`);
    console.log(`ðŸ“… Generated: ${embeddingData.metadata?.timestamp || 'unknown'}`);
    console.log(`ðŸ’¾ Source: ${source.type}`);

	this.updateLoadingStatus(`Loaded ${embeddingData.embeddings.length} embeddings`);
}

async createTensorInBatches(embeddings) {
    const batchSize = 1000;
    const batches = [];
    
    console.log(`ðŸ”„ Creating tensor in batches of ${batchSize}...`);
    
    for (let i = 0; i < embeddings.length; i += batchSize) {
        const batch = embeddings.slice(i, i + batchSize);
        const batchTensor = tf.tensor2d(batch);
        batches.push(batchTensor);
        
        // Progress update
        if (i % (batchSize * 10) === 0) {
            console.log(`ðŸ“Š Processed ${i + batchSize}/${embeddings.length} embeddings...`);
            // Yield control
            await new Promise(resolve => setTimeout(resolve, 10));
        }
    }
    
    // Concatenate all batches
    console.log('ðŸ”— Concatenating tensor batches...');
    this.embeddingsTensor = tf.concat(batches, 0);
    
    // Clean up batch tensors
    batches.forEach(batch => batch.dispose());
    
    console.log('âœ… Tensor creation complete');
}

// Enhanced validation with better error messages
validateEmbeddingData(data) {
    if (!data) {
        console.log('âŒ Validation failed: No data');
        return false;
    }
    
    if (!data.embeddings || !Array.isArray(data.embeddings)) {
        console.log('âŒ Validation failed: Missing or invalid embeddings array');
        return false;
    }
    
    if (!data.labels || !Array.isArray(data.labels)) {
        console.log('âŒ Validation failed: Missing or invalid labels array');
        return false;
    }
    
    if (!data.texts || !Array.isArray(data.texts)) {
        console.log('âŒ Validation failed: Missing or invalid texts array');
        return false;
    }
    
    if (data.embeddings.length !== data.labels.length) {
        console.log(`âŒ Validation failed: Embeddings (${data.embeddings.length}) and labels (${data.labels.length}) length mismatch`);
        return false;
    }
    
    if (data.embeddings.length !== data.texts.length) {
        console.log(`âŒ Validation failed: Embeddings (${data.embeddings.length}) and texts (${data.texts.length}) length mismatch`);
        return false;
    }
    
    if (data.embeddings.length === 0) {
        console.log('âŒ Validation failed: Empty embeddings array');
        return false;
    }
    
    // Validate first embedding structure
    const firstEmbedding = data.embeddings[0];
    if (!Array.isArray(firstEmbedding) || firstEmbedding.length === 0) {
        console.log('âŒ Validation failed: Invalid embedding structure');
        return false;
    }
    
    console.log('âœ… Embedding data validation passed');
    return true;
}

// Additional optimization method
async optimizeEmbeddingStorage(embeddingData) {
    console.log('ðŸ”§ Applying additional optimizations...');
    
    // Create indexed lookup structures for faster search
    this.embeddingIndex = this.createEmbeddingIndex(embeddingData);
    
    // Pre-normalize embeddings for faster cosine similarity
    if (this.embeddingsTensor) {
        const norms = tf.norm(this.embeddingsTensor, 'euclidean', 1, true);
        this.normalizedEmbeddingsTensor = tf.div(this.embeddingsTensor, norms);
        norms.dispose(); // Clean up
        
        console.log('âœ… Embeddings pre-normalized for optimized similarity computation');
    }
    
    // Create category-based indices for faster filtering
    this.categoryIndices = this.createCategoryIndices(embeddingData.labels);
    
    console.log('ðŸš€ All optimizations applied successfully');
}

// Create embedding index for faster lookups
createEmbeddingIndex(embeddingData) {
    const index = {
        byType: new Map(),
        bySystem: new Map(),
        byHPOId: new Map()
    };
    
    embeddingData.labels.forEach((label, i) => {
        // Index by type
        if (!index.byType.has(label.type)) {
            index.byType.set(label.type, []);
        }
        index.byType.get(label.type).push(i);
        
        // Index by anatomical system
        const system = this.inferAnatomicalSystem(label.name, label.definition);
        if (!index.bySystem.has(system)) {
            index.bySystem.set(system, []);
        }
        index.bySystem.get(system).push(i);
        
        // Index by HPO ID
        if (label.id && label.id.startsWith('HP_')) {
            index.byHPOId.set(label.id, i);
        }
    });
    
    return index;
}

// Create category indices for filtering
createCategoryIndices(labels) {
    return {
        symptoms: labels.map((label, i) => 
            ['hpo_term', 'hpo_synonym', 'fallback_symptom'].includes(label.type) ? i : -1
        ).filter(i => i !== -1),
        
        conditions: labels.map((label, i) => 
            label.type === 'condition' ? i : -1
        ).filter(i => i !== -1),
        
        highConfidence: labels.map((label, i) => 
            label.confidence && label.confidence > 0.8 ? i : -1
        ).filter(i => i !== -1)
    };
}

            validateEmbeddingData(data) {
                return data && 
                       data.embeddings && 
                       Array.isArray(data.embeddings) && 
                       data.labels && 
                       Array.isArray(data.labels) && 
                       data.texts && 
                       Array.isArray(data.texts) &&
                       data.embeddings.length === data.labels.length &&
                       data.embeddings.length === data.texts.length;
            }

            createFallbackEmbeddings() {
                // Create minimal embeddings for demonstration
                const fallbackTexts = [
                    'headache', 'chest pain', 'abdominal pain', 'nausea', 'fever', 
                    'shortness of breath', 'dizziness', 'fatigue', 'weakness'
                ];
                
                const fallbackLabels = fallbackTexts.map((text, index) => ({
                    type: 'fallback_symptom',
                    id: `fallback_${index}`,
                    name: text
                }));

                // Create random embeddings for fallback (512 dimensions like USE)
                const fallbackEmbeddings = fallbackTexts.map(() => 
                    Array.from({length: 512}, () => Math.random() - 0.5)
                );

                this.precomputedEmbeddings = {
                    metadata: {
                        version: 'fallback-mode',
                        timestamp: new Date().toISOString(),
                        totalEmbeddings: fallbackEmbeddings.length,
                        embeddingDimension: 512
                    },
                    embeddings: fallbackEmbeddings,
                    labels: fallbackLabels,
                    texts: fallbackTexts
                };

                this.embeddingsTensor = tf.tensor2d(fallbackEmbeddings);
                console.log('ðŸ”„ Created fallback embeddings');
            }

            async loadBasicKnowledgeBases() {
                // Load minimal knowledge bases for fallback
                try {
                    const hpoResponse = await fetch('assets/hp.json');
                    if (hpoResponse.ok) {
                        this.hpoData = await hpoResponse.json();
                        console.log('ðŸ“š HPO data loaded');
                    }
                } catch (error) {
                    this.hpoData = this.createSampleHPOData();
                    console.log('ðŸ“š Using sample HPO data');
                }

                try {
                    const kbResponse = await fetch('assets/Biomedical_Knowledgebase.json');
                    if (kbResponse.ok) {
                        this.biomedicalKB = await kbResponse.json();
                        console.log('ðŸ“– Biomedical KB loaded');
                    }
                } catch (error) {
                    this.biomedicalKB = this.createFallbackKB();
                    console.log('ðŸ“– Using fallback KB');
                }
            }

            async analyzeClinicalPresentation(inputText) {
                console.log('ðŸ” Starting optimized ML clinical analysis...');
                
                if (!this.isReady || !this.useModel) {
                    throw new Error('ML engine not ready');
                }

                // Step 1: Generate embedding for input text (only computation needed)
                const inputEmbedding = await this.generateInputEmbedding(inputText);
                
                // Step 2: Find semantically similar clinical concepts using pre-computed embeddings
                const semanticMatches = await this.findSemanticMatchesOptimized(inputEmbedding, inputText);
                
                // Step 3: Extract symptoms using ML + rule-based hybrid approach
                const detectedSymptoms = await this.extractSymptomsML(inputText, semanticMatches);
                
                // Step 4: Map to conditions using neural similarity
                const mappedConditions = await this.mapConditionsML(detectedSymptoms, semanticMatches);
                
                // Step 5: Generate treatment pathways
                const treatmentPaths = await this.generateTreatmentPathsML(mappedConditions);
                
                // Step 6: Build clinical workflow
                const clinicalWorkflow = this.buildClinicalWorkflow(detectedSymptoms, mappedConditions, treatmentPaths);
                
                // Clean up GPU memory
                inputEmbedding.dispose();
                
                return {
                    symptoms: detectedSymptoms,
                    conditions: mappedConditions,
                    treatments: treatmentPaths,
                    workflow: clinicalWorkflow,
                    semanticMatches: semanticMatches.slice(0, 10),
                    confidence: this.calculateOverallConfidence(detectedSymptoms, mappedConditions),
                    mlMetrics: {
                        embeddingDimensions: this.precomputedEmbeddings?.metadata?.embeddingDimension || 512,
                        backend: tf.getBackend(),
                        memory: tf.memory(),
                        precomputedEmbeddings: this.precomputedEmbeddings?.embeddings?.length || 0,
                        embeddingSource: this.precomputedEmbeddings?.metadata?.version || 'unknown'
                    }
                };
            }

            async generateInputEmbedding(inputText) {
                const preprocessedText = this.preprocessMedicalText(inputText);
                const embedding = await this.useModel.embed([preprocessedText]);
                return embedding;
            }

            preprocessMedicalText(text) {
                let processed = text.toLowerCase();
                
                // Medical abbreviations
                const medicalAbbreviations = {
                    'pt': 'patient', 'hx': 'history', 'dx': 'diagnosis', 'tx': 'treatment',
                    'sx': 'symptoms', 'w/': 'with', 'c/o': 'complains of', 'sob': 'shortness of breath',
                    'cp': 'chest pain', 'ha': 'headache', 'n/v': 'nausea and vomiting',
                    'abd': 'abdominal', 'rle': 'right lower extremity', 'lle': 'left lower extremity'
                };
                
                Object.entries(medicalAbbreviations).forEach(([abbrev, expansion]) => {
                    const regex = new RegExp(`\\b${abbrev}\\b`, 'gi');
                    processed = processed.replace(regex, expansion);
                });
                
                // Expand symptom descriptions
                processed = processed.replace(/\bpain\b/g, 'pain discomfort ache');
                processed = processed.replace(/\bheadache\b/g, 'headache head pain cephalgia');
                processed = processed.replace(/\bnausea\b/g, 'nausea sick stomach');
                
                return processed;
            }

// Enhanced semantic matching with precomputed embeddings
async findSemanticMatchesOptimized(inputEmbedding, inputText) {
    if (!this.normalizedEmbeddingsTensor) {
        return [];
    }
    
    console.log('ðŸ§® Computing semantic similarities using optimized precomputed embeddings...');
    
    // Normalize input embedding
    const inputNorm = tf.norm(inputEmbedding, 'euclidean', 1, true);
    const normalizedInput = tf.div(inputEmbedding, inputNorm);
    
    // Use pre-normalized embeddings for ultra-fast computation
    const similarities = tf.matMul(normalizedInput, this.normalizedEmbeddingsTensor, false, true);
    const similarityArray = await similarities.array();
    
    // Clean up intermediate tensors
    inputNorm.dispose();
    normalizedInput.dispose();
    similarities.dispose();
    
    // Apply intelligent filtering and ranking
    const results = this.applyIntelligentFiltering(similarityArray[0], inputText);
    
    console.log(`âœ… Found ${results.length} semantic matches using optimized computation`);
    return results;
}

// Intelligent filtering based on context and categories
applyIntelligentFiltering(similarities, inputText) {
    const results = [];
    const inputLower = inputText.toLowerCase();
    
    // Determine input context for smart filtering
    const contextWeights = this.analyzeInputContext(inputText);
    
    for (let i = 0; i < similarities.length; i++) {
        const similarity = similarities[i];
        const label = this.precomputedEmbeddings.labels[i];
        const text = this.precomputedEmbeddings.texts[i];
        
        // Base similarity threshold
        let threshold = 0.2;
        
        // Adjust threshold based on label type and context
        if (label.type === 'hpo_term' && contextWeights.symptoms > 0.5) {
            threshold = 0.15; // Lower threshold for symptoms
        } else if (label.type === 'condition' && contextWeights.conditions > 0.5) {
            threshold = 0.2;
        } else if (label.type === 'hpo_definition' && similarity > 0.4) {
            threshold = 0.3; // Higher threshold for definitions
        }
        
        // Apply context boost
        let adjustedSimilarity = similarity;
        if (label.type === 'hpo_term' && contextWeights.symptoms > 0.3) {
            adjustedSimilarity *= (1 + contextWeights.symptoms * 0.2);
        }
        
        if (adjustedSimilarity > threshold) {
            results.push({
                similarity: adjustedSimilarity,
                originalSimilarity: similarity,
                label: label,
                text: text,
                contextBoost: adjustedSimilarity - similarity
            });
        }
    }
    
    // Advanced ranking with multiple factors
    return results
        .sort((a, b) => {
            // Primary: adjusted similarity
            if (Math.abs(a.similarity - b.similarity) > 0.05) {
                return b.similarity - a.similarity;
            }
            
            // Secondary: label type preference
            const typeRanking = {
                'hpo_term': 3,
                'condition': 2,
                'hpo_synonym': 1,
                'hpo_definition': 0
            };
            const aRank = typeRanking[a.label.type] || 0;
            const bRank = typeRanking[b.label.type] || 0;
            
            return bRank - aRank;
        })
        .slice(0, 150); // Increased from 100 for better coverage
}

// Analyze input text context for smart filtering
analyzeInputContext(inputText) {
    const text = inputText.toLowerCase();
    
    // Symptom indicators
    const symptomKeywords = [
        'pain', 'ache', 'headache', 'nausea', 'fever', 'fatigue', 'weakness',
        'shortness', 'breath', 'dizzy', 'chest', 'abdominal', 'presents with',
        'complains of', 'experiencing', 'reports'
    ];
    
    // Condition indicators
    const conditionKeywords = [
        'diagnosis', 'condition', 'disease', 'syndrome', 'disorder',
        'history of', 'diagnosed with', 'chronic', 'acute'
    ];
    
    // Treatment indicators
    const treatmentKeywords = [
        'treatment', 'therapy', 'medication', 'surgery', 'procedure',
        'intervention', 'management'
    ];
    
    const symptomScore = symptomKeywords.reduce((score, keyword) => 
        score + (text.includes(keyword) ? 1 : 0), 0) / symptomKeywords.length;
    
    const conditionScore = conditionKeywords.reduce((score, keyword) => 
        score + (text.includes(keyword) ? 1 : 0), 0) / conditionKeywords.length;
    
    const treatmentScore = treatmentKeywords.reduce((score, keyword) => 
        score + (text.includes(keyword) ? 1 : 0), 0) / treatmentKeywords.length;
    
    return {
        symptoms: Math.min(symptomScore * 2, 1), // Boost symptom detection
        conditions: conditionScore,
        treatments: treatmentScore
    };
}

// Enhanced batch processing for multiple queries
async processBatchQueries(queries) {
    console.log(`ðŸ”„ Processing ${queries.length} queries in optimized batch mode...`);
    
    if (!this.normalizedEmbeddingsTensor) {
        throw new Error('Normalized embeddings not available');
    }
    
    // Generate embeddings for all queries at once
    const queryEmbeddings = await this.useModel.embed(queries);
    const queryArray = await queryEmbeddings.array();
    
    // Normalize query embeddings
    const queryTensor = tf.tensor2d(queryArray);
    const queryNorms = tf.norm(queryTensor, 'euclidean', 1, true);
    const normalizedQueries = tf.div(queryTensor, queryNorms);
    
    // Compute similarities for all queries at once
    const batchSimilarities = tf.matMul(
        normalizedQueries, 
        this.normalizedEmbeddingsTensor, 
        false, 
        true
    );
    const similarityMatrix = await batchSimilarities.array();
    
    // Clean up tensors
    queryEmbeddings.dispose();
    queryTensor.dispose();
    queryNorms.dispose();
    normalizedQueries.dispose();
    batchSimilarities.dispose();
    
    // Process results for each query
    const results = [];
    for (let i = 0; i < queries.length; i++) {
        const queryResults = this.applyIntelligentFiltering(
            similarityMatrix[i], 
            queries[i]
        );
        results.push({
            query: queries[i],
            matches: queryResults.slice(0, 50)
        });
    }
    
    console.log('âœ… Batch processing completed');
    return results;
}

// Precomputed embedding statistics and insights
generateEmbeddingStatistics() {
    if (!this.precomputedEmbeddings) return null;
    
    const labels = this.precomputedEmbeddings.labels;
    const embeddings = this.precomputedEmbeddings.embeddings;
    
    // Type distribution
    const typeDistribution = {};
    labels.forEach(label => {
        typeDistribution[label.type] = (typeDistribution[label.type] || 0) + 1;
    });
    
    // System distribution
    const systemDistribution = {};
    labels.forEach(label => {
        const system = this.inferAnatomicalSystem(label.name, label.definition);
        systemDistribution[system] = (systemDistribution[system] || 0) + 1;
    });
    
    // Embedding dimension statistics
    const dimensions = embeddings[0]?.length || 0;
    let totalNorm = 0;
    let maxNorm = 0;
    let minNorm = Infinity;
    
    embeddings.forEach(embedding => {
        const norm = Math.sqrt(embedding.reduce((sum, val) => sum + val * val, 0));
        totalNorm += norm;
        maxNorm = Math.max(maxNorm, norm);
        minNorm = Math.min(minNorm, norm);
    });
    
    const avgNorm = totalNorm / embeddings.length;
    
    return {
        totalEmbeddings: embeddings.length,
        dimensions: dimensions,
        typeDistribution: typeDistribution,
        systemDistribution: systemDistribution,
        embeddingNorms: {
            average: avgNorm.toFixed(4),
            maximum: maxNorm.toFixed(4),
            minimum: minNorm.toFixed(4)
        },
        memoryUsage: {
            estimated: `${(embeddings.length * dimensions * 4 / 1024 / 1024).toFixed(1)} MB`,
            tensorMemory: this.embeddingsTensor ? 
                `${(this.embeddingsTensor.size * 4 / 1024 / 1024).toFixed(1)} MB` : 'N/A'
        },
        indexStructures: {
            categoryIndices: Object.keys(this.categoryIndices || {}),
            embeddingIndex: this.embeddingIndex ? 
                Object.keys(this.embeddingIndex).length : 0
        }
    };
}

// Advanced similarity search with filters
async advancedSimilaritySearch(inputText, options = {}) {
    const {
        filterByType = null,
        filterBySystem = null,
        minSimilarity = 0.2,
        maxResults = 100,
        boost = {}
    } = options;
    
    // Generate input embedding
    const inputEmbedding = await this.generateInputEmbedding(inputText);
    
    // Get base similarities
    const similarities = await this.findSemanticMatchesOptimized(inputEmbedding, inputText);
    
    // Apply filters
    let filteredResults = similarities;
    
    if (filterByType) {
        filteredResults = filteredResults.filter(result => 
            result.label.type === filterByType
        );
    }
    
    if (filterBySystem) {
        filteredResults = filteredResults.filter(result => {
            const system = this.inferAnatomicalSystem(result.label.name, result.label.definition);
            return system === filterBySystem;
        });
    }
    
    // Apply similarity threshold
    filteredResults = filteredResults.filter(result => 
        result.similarity >= minSimilarity
    );
    
    // Apply boosts
    if (Object.keys(boost).length > 0) {
        filteredResults.forEach(result => {
            if (boost[result.label.type]) {
                result.similarity *= boost[result.label.type];
            }
        });
        
        // Re-sort after boosts
        filteredResults.sort((a, b) => b.similarity - a.similarity);
    }
    
    // Clean up
    inputEmbedding.dispose();
    
    return filteredResults.slice(0, maxResults);
}

// Memory optimization for large embedding sets
optimizeMemoryUsage() {
    console.log('ðŸ”§ Optimizing memory usage...');
    
    // Clean up unnecessary data structures
    if (this.embeddingsTensor && this.normalizedEmbeddingsTensor) {
        // We only need normalized tensors for similarity computation
        this.embeddingsTensor.dispose();
        this.embeddingsTensor = null;
        console.log('âœ… Disposed unnormalized embedding tensor');
    }
    
    // Optionally compress label data
    if (this.precomputedEmbeddings?.labels) {
        // Keep only essential label fields
        this.precomputedEmbeddings.labels = this.precomputedEmbeddings.labels.map(label => ({
            id: label.id,
            name: label.name,
            type: label.type,
            definition: label.definition ? label.definition.substring(0, 200) : undefined
        }));
        console.log('âœ… Compressed label data');
    }
    
    // Force garbage collection if available
    if (window.gc) {
        window.gc();
    }
    
    const memInfo = tf.memory();
    console.log(`ðŸ’¾ Memory optimization complete. GPU memory: ${Math.round(memInfo.numBytesInGPU / 1024 / 1024)}MB`);
}

            async extractSymptomsML(inputText, semanticMatches) {
                const symptoms = [];
                const seenSymptoms = new Set();
                
                // Process semantic matches to extract symptoms
                semanticMatches.forEach(match => {
                    if ((match.label.type === 'hpo_term' || 
                         match.label.type === 'hpo_synonym' || 
                         match.label.type === 'fallback_symptom') && 
                        match.similarity > 0.3) {
                        
                        const symptomKey = match.label.name.toLowerCase();
                        
                        if (!seenSymptoms.has(symptomKey)) {
                            seenSymptoms.add(symptomKey);
                            
                            symptoms.push({
                                id: match.label.id,
                                name: match.label.name,
                                hpoId: match.label.id,
                                definition: match.label.definition || '',
                                confidence: match.similarity,
                                semanticSimilarity: match.similarity,
                                matchedText: match.text,
                                severity: this.inferSeverity(inputText, match.label.name),
                                temporal: this.inferTemporal(inputText, match.label.name),
                                anatomicalSystem: this.inferAnatomicalSystem(match.label.name, match.label.definition),
                                source: 'ml_precomputed_matching'
                            });
                        }
                    }
                });
                
                // Add rule-based symptom extraction for robustness
                const ruleBasedSymptoms = this.extractSymptomsRuleBased(inputText);
                ruleBasedSymptoms.forEach(symptom => {
                    const symptomKey = symptom.name.toLowerCase();
                    if (!seenSymptoms.has(symptomKey)) {
                        symptoms.push(symptom);
                    }
                });
                
                return symptoms.sort((a, b) => b.confidence - a.confidence).slice(0, 8);
            }

            extractSymptomsRuleBased(inputText) {
                const symptoms = [];
                const text = inputText.toLowerCase();
                
                const symptomPatterns = [
                    { pattern: /\b(severe|intense|sharp|throbbing|dull|mild|moderate)?\s*(headache|head\s*ache|migraine|cephalgia)\b/g, 
                      name: 'headache', severity: 'moderate', system: 'neurological' },
                    { pattern: /\b(chest|thoracic)\s*(pain|discomfort|ache)\b/g, 
                      name: 'chest pain', severity: 'moderate', system: 'cardiovascular' },
                    { pattern: /\b(abdominal|stomach|belly)\s*(pain|ache|cramps?)\b/g, 
                      name: 'abdominal pain', severity: 'moderate', system: 'gastrointestinal' },
                    { pattern: /\b(nausea|nauseated|sick|queasy)\b/g, 
                      name: 'nausea', severity: 'mild', system: 'gastrointestinal' },
                    { pattern: /\b(fever|febrile|temperature|hot)\b/g, 
                      name: 'fever', severity: 'moderate', system: 'general' },
                    { pattern: /\b(fatigue|tired|exhausted|weakness|weak)\b/g, 
                      name: 'fatigue', severity: 'mild', system: 'general' },
                    { pattern: /\b(shortness\s*of\s*breath|dyspnea|difficulty\s*breathing)\b/g, 
                      name: 'dyspnea', severity: 'moderate', system: 'respiratory' },
                    { pattern: /\b(dizziness|dizzy|vertigo|lightheaded)\b/g, 
                      name: 'dizziness', severity: 'mild', system: 'neurological' }
                ];
                
                symptomPatterns.forEach(({ pattern, name, severity, system }) => {
                    const matches = text.match(pattern);
                    if (matches) {
                        symptoms.push({
                            id: name.replace(/\s+/g, '_'),
                            name: name,
                            confidence: 0.8,
                            severity: severity,
                            temporal: 'acute',
                            anatomicalSystem: system,
                            source: 'rule_based_extraction',
                            matchedText: matches[0]
                        });
                    }
                });
                
                return symptoms;
            }

            inferSeverity(inputText, symptomName) {
                const text = inputText.toLowerCase();
                if (text.includes('severe') || text.includes('intense') || text.includes('excruciating')) return 'severe';
                if (text.includes('moderate') || text.includes('significant')) return 'moderate';
                if (text.includes('mild') || text.includes('slight') || text.includes('minor')) return 'mild';
                if (['headache', 'chest pain', 'abdominal pain'].includes(symptomName.toLowerCase())) return 'moderate';
                return 'mild';
            }

            inferTemporal(inputText, symptomName) {
                const text = inputText.toLowerCase();
                if (text.includes('chronic') || text.includes('persistent') || text.includes('ongoing')) return 'chronic';
                if (text.includes('acute') || text.includes('sudden') || text.includes('rapid')) return 'acute';
                if (text.includes('recurrent') || text.includes('episodic')) return 'recurrent';
                return 'acute';
            }

            inferAnatomicalSystem(symptomName, definition) {
                const text = (symptomName + ' ' + (definition || '')).toLowerCase();
                const systemMap = {
                    'neurological': ['brain', 'neural', 'nerve', 'headache', 'cognitive', 'seizure'],
                    'cardiovascular': ['heart', 'cardiac', 'chest', 'blood', 'vessel', 'circulation'],
                    'respiratory': ['lung', 'breathing', 'dyspnea', 'cough', 'respiratory'],
                    'gastrointestinal': ['stomach', 'intestinal', 'nausea', 'vomiting', 'abdominal'],
                    'genitourinary': ['kidney', 'urinary', 'bladder', 'urine'],
                    'musculoskeletal': ['muscle', 'bone', 'joint', 'skeletal'],
                    'general': ['fever', 'fatigue', 'weakness']
                };
                
                for (const [system, keywords] of Object.entries(systemMap)) {
                    if (keywords.some(keyword => text.includes(keyword))) {
                        return system;
                    }
                }
                return 'general';
            }

            async mapConditionsML(symptoms, semanticMatches) {
                const conditions = [];
                const conditionScores = new Map();
                
                // Process semantic matches for conditions
                semanticMatches.forEach(match => {
                    if (match.label.type === 'condition' && match.similarity > 0.25) {
                        const conditionId = match.label.id;
                        const existingScore = conditionScores.get(conditionId) || 0;
                        conditionScores.set(conditionId, Math.max(existingScore, match.similarity));
                    }
                });
                
                // Convert to condition objects
                conditionScores.forEach((score, conditionId) => {
                    const conditionData = this.findConditionData(conditionId);
                    if (conditionData) {
                        conditions.push({
                            id: conditionId,
                            name: conditionData.name,
                            description: conditionData.description || `Clinical condition: ${conditionData.name}`,
                            probability: score,
                            adjustedProbability: score,
                            confidence: score,
                            severity: conditionData.severity || 'moderate',
                            prognosis: conditionData.prognosis || 'Variable prognosis with appropriate treatment',
                            chronicityRisk: conditionData.chronicityRisk || 0.5,
                            evidence: [{
                                type: 'ml_precomputed_similarity',
                                strength: score,
                                source: 'Pre-computed Neural Embeddings'
                            }],
                            supportingSymptoms: symptoms.filter(s => s.confidence > 0.5),
                            treatments: this.getTreatmentsForCondition(conditionId),
                            source: 'ml_precomputed_mapping'
                        });
                    }
                });
                
                // Add symptom-based condition mapping
                const symptomBasedConditions = this.mapConditionsFromSymptoms(symptoms);
                symptomBasedConditions.forEach(condition => {
                    const existing = conditions.find(c => c.id === condition.id);
                    if (!existing) {
                        conditions.push(condition);
                    } else {
                        existing.adjustedProbability = Math.min(existing.adjustedProbability + 0.1, 0.95);
                    }
                });
                
                return conditions.sort((a, b) => b.adjustedProbability - a.adjustedProbability).slice(0, 6);
            }

            mapConditionsFromSymptoms(symptoms) {
                const conditions = [];
                
                const symptomConditionMap = {
                    'headache': [
                        { condition: 'migraine', probability: 0.7 },
                        { condition: 'tension_headache', probability: 0.6 },
                        { condition: 'cluster_headache', probability: 0.4 }
                    ],
                    'chest pain': [
                        { condition: 'myocardial_infarction', probability: 0.6 },
                        { condition: 'angina', probability: 0.7 },
                        { condition: 'pulmonary_embolism', probability: 0.4 }
                    ],
                    'abdominal pain': [
                        { condition: 'appendicitis', probability: 0.5 },
                        { condition: 'kidney_stones', probability: 0.6 },
                        { condition: 'gallstones', probability: 0.5 }
                    ],
                    'nausea': [
                        { condition: 'gastroenteritis', probability: 0.6 },
                        { condition: 'migraine', probability: 0.4 }
                    ],
                    'fever': [
                        { condition: 'infection', probability: 0.8 },
                        { condition: 'pneumonia', probability: 0.6 }
                    ],
                    'dyspnea': [
                        { condition: 'asthma', probability: 0.6 },
                        { condition: 'heart_failure', probability: 0.5 },
                        { condition: 'pneumonia', probability: 0.6 }
                    ]
                };
                
                symptoms.forEach(symptom => {
                    const symptomKey = symptom.name.toLowerCase();
                    const mappings = symptomConditionMap[symptomKey] || [];
                    
                    mappings.forEach(mapping => {
                        const conditionData = this.getConditionTemplate(mapping.condition);
                        const probability = mapping.probability * symptom.confidence;
                        
                        if (probability > 0.3) {
                            conditions.push({
                                id: mapping.condition,
                                name: conditionData.name,
                                description: conditionData.description,
                                probability: probability,
                                adjustedProbability: probability,
                                confidence: probability,
                                severity: conditionData.severity,
                                prognosis: conditionData.prognosis,
                                chronicityRisk: conditionData.chronicityRisk,
                                evidence: [{
                                    type: 'symptom_based_mapping',
                                    strength: probability,
                                    source: 'Medical Knowledge Base'
                                }],
                                supportingSymptoms: [symptom],
                                treatments: this.getTreatmentsForCondition(mapping.condition),
                                source: 'symptom_condition_mapping'
                            });
                        }
                    });
                });
                
                return conditions;
            }

            findConditionData(conditionId) {
                if (this.biomedicalKB?.conditions?.[conditionId]) {
                    return this.biomedicalKB.conditions[conditionId];
                }
                return this.getConditionTemplate(conditionId);
            }

            getConditionTemplate(conditionId) {
                const templates = {
                    'migraine': {
                        name: 'Migraine', description: 'Recurrent headache disorder characterized by throbbing pain',
                        severity: 'moderate_to_severe', prognosis: 'Good with appropriate treatment and trigger management', chronicityRisk: 0.7
                    },
                    'tension_headache': {
                        name: 'Tension Headache', description: 'Most common type of headache, often stress-related',
                        severity: 'mild_to_moderate', prognosis: 'Excellent with stress management and treatment', chronicityRisk: 0.3
                    },
                    'myocardial_infarction': {
                        name: 'Myocardial Infarction', description: 'Heart attack due to blocked coronary artery',
                        severity: 'severe', prognosis: 'Variable; excellent with rapid treatment', chronicityRisk: 0.9
                    },
                    'angina': {
                        name: 'Angina Pectoris', description: 'Chest pain due to reduced blood flow to heart',
                        severity: 'moderate_to_severe', prognosis: 'Good with appropriate cardiac management', chronicityRisk: 0.8
                    },
                    'appendicitis': {
                        name: 'Appendicitis', description: 'Inflammation of the appendix',
                        severity: 'moderate_to_severe', prognosis: 'Excellent with surgical treatment', chronicityRisk: 0.1
                    },
                    'kidney_stones': {
                        name: 'Kidney Stones', description: 'Hard deposits in the kidney causing pain',
                        severity: 'severe', prognosis: 'Good; high recurrence risk without prevention', chronicityRisk: 0.6
                    },
                    'gastroenteritis': {
                        name: 'Gastroenteritis', description: 'Inflammation of stomach and intestines',
                        severity: 'mild_to_moderate', prognosis: 'Excellent; self-limiting condition', chronicityRisk: 0.1
                    },
                    'pneumonia': {
                        name: 'Pneumonia', description: 'Infection of the lungs',
                        severity: 'moderate_to_severe', prognosis: 'Good with appropriate antibiotic treatment', chronicityRisk: 0.2
                    },
                    'asthma': {
                        name: 'Asthma', description: 'Chronic respiratory condition with airway inflammation',
                        severity: 'mild_to_severe', prognosis: 'Good with proper management and medications', chronicityRisk: 0.9
                    },
                    'heart_failure': {
                        name: 'Heart Failure', description: 'Heart unable to pump blood effectively',
                        severity: 'moderate_to_severe', prognosis: 'Variable; manageable with appropriate treatment', chronicityRisk: 0.95
                    }
                };
                
                return templates[conditionId] || {
                    name: conditionId.replace(/_/g, ' '), description: `Medical condition: ${conditionId.replace(/_/g, ' ')}`,
                    severity: 'moderate', prognosis: 'Variable prognosis with appropriate treatment', chronicityRisk: 0.5
                };
            }

            getTreatmentsForCondition(conditionId) {
                const treatmentMap = {
                    'migraine': [
                        { id: 'triptans', name: 'Triptan Medications', efficacy: 0.85, cost: 200, sideEffects: 0.25 },
                        { id: 'preventive_therapy', name: 'Preventive Therapy', efficacy: 0.70, cost: 150, sideEffects: 0.30 }
                    ],
                    'tension_headache': [
                        { id: 'analgesics', name: 'Over-the-counter Analgesics', efficacy: 0.80, cost: 20, sideEffects: 0.15 },
                        { id: 'stress_management', name: 'Stress Management', efficacy: 0.70, cost: 100, sideEffects: 0.05 }
                    ],
                    'myocardial_infarction': [
                        { id: 'pci', name: 'Percutaneous Coronary Intervention', efficacy: 0.90, cost: 50000, sideEffects: 0.20 },
                        { id: 'thrombolysis', name: 'Thrombolytic Therapy', efficacy: 0.75, cost: 15000, sideEffects: 0.30 }
                    ],
                    'angina': [
                        { id: 'nitrates', name: 'Nitrate Medications', efficacy: 0.80, cost: 100, sideEffects: 0.20 },
                        { id: 'beta_blockers', name: 'Beta Blockers', efficacy: 0.75, cost: 150, sideEffects: 0.25 }
                    ],
                    'appendicitis': [
                        { id: 'appendectomy', name: 'Appendectomy', efficacy: 0.95, cost: 15000, sideEffects: 0.20 }
                    ],
                    'kidney_stones': [
                        { id: 'lithotripsy', name: 'Shock Wave Lithotripsy', efficacy: 0.80, cost: 8000, sideEffects: 0.25 },
                        { id: 'pain_management_stones', name: 'Pain Management', efficacy: 0.85, cost: 200, sideEffects: 0.30 }
                    ],
                    'gastroenteritis': [
                        { id: 'supportive_care_gi', name: 'Supportive Care', efficacy: 0.90, cost: 100, sideEffects: 0.05 },
                        { id: 'rehydration', name: 'Oral Rehydration Therapy', efficacy: 0.95, cost: 50, sideEffects: 0.02 }
                    ],
                    'pneumonia': [
                        { id: 'antibiotics_pneumonia', name: 'Antibiotic Therapy', efficacy: 0.90, cost: 300, sideEffects: 0.20 }
                    ],
                    'asthma': [
                        { id: 'bronchodilators', name: 'Bronchodilator Medications', efficacy: 0.85, cost: 200, sideEffects: 0.20 },
                        { id: 'inhaled_corticosteroids', name: 'Inhaled Corticosteroids', efficacy: 0.80, cost: 150, sideEffects: 0.25 }
                    ],
                    'heart_failure': [
                        { id: 'ace_inhibitors', name: 'ACE Inhibitors', efficacy: 0.80, cost: 100, sideEffects: 0.25 },
                        { id: 'diuretics', name: 'Diuretic Therapy', efficacy: 0.75, cost: 80, sideEffects: 0.30 }
                    ]
                };
                
                return treatmentMap[conditionId] || [
                    { id: 'supportive_care', name: 'Supportive Care', efficacy: 0.70, cost: 500, sideEffects: 0.10 }
                ];
            }

            async generateTreatmentPathsML(conditions) {
                const treatmentPaths = [];
                
                conditions.forEach(condition => {
                    const treatments = this.getTreatmentsForCondition(condition.id);
                    
                    treatments.forEach(treatment => {
                        const enhancedTreatment = this.enhanceTreatmentWithML(treatment, condition);
                        const statistics = this.runEnhancedSimulations(enhancedTreatment, condition);
                        
                        treatmentPaths.push({
                            condition: condition,
                            treatment: enhancedTreatment,
                            statistics: statistics,
                            mlScore: this.calculateMLTreatmentScore(enhancedTreatment, condition),
                            evidenceLevel: this.calculateEvidenceLevel(condition, enhancedTreatment),
                            recommendation: this.generateMLRecommendation(enhancedTreatment, condition, statistics)
                        });
                    });
                });
                
                return treatmentPaths.sort((a, b) => b.mlScore - a.mlScore);
            }

            enhanceTreatmentWithML(treatment, condition) {
                return {
                    id: treatment.id || `treatment_${Date.now()}`,
                    name: treatment.name || 'Standard Treatment',
                    description: treatment.description || `Treatment for ${condition.name}`,
                    efficacy: treatment.efficacy || 0.7,
                    cost: treatment.cost || 1000,
                    sideEffects: treatment.sideEffects || 0.2,
                    contraindications: treatment.contraindications || [],
                    mechanismOfAction: this.inferMechanismOfAction(treatment, condition),
                    expectedTimeline: this.predictTreatmentTimeline(treatment, condition),
                    personalizedRisk: this.calculatePersonalizedRisk(treatment, condition),
                    mlConfidence: this.calculateMLConfidence(treatment, condition)
                };
            }

            calculateMLTreatmentScore(treatment, condition) {
                let score = 0;
                score += treatment.efficacy * 0.4;
                score += (1 - treatment.sideEffects) * 0.3;
                const costScore = Math.max(0, 1 - (treatment.cost / 10000));
                score += costScore * 0.2;
                score += (treatment.mlConfidence || 0.7) * 0.1;
                return Math.min(score, 1.0);
            }

            calculateEvidenceLevel(condition, treatment) {
                const efficacy = treatment.efficacy || 0.7;
                const conditionConfidence = condition.confidence || 0.7;
                const combined = efficacy * conditionConfidence;
                
                if (combined > 0.85) return 'Level I (High)';
                if (combined > 0.70) return 'Level II (Moderate-High)';
                if (combined > 0.55) return 'Level III (Moderate)';
                return 'Level IV (Low-Moderate)';
            }

            generateMLRecommendation(treatment, condition, statistics) {
                const efficacy = treatment.efficacy || 0.7;
                const mlScore = this.calculateMLTreatmentScore(treatment, condition);
                
                if (mlScore > 0.8 && efficacy > 0.85) {
                    return `Highly recommended: Optimized ML analysis indicates excellent treatment match with ${(efficacy * 100).toFixed(0)}% efficacy`;
                } else if (mlScore > 0.6 && treatment.sideEffects < 0.25) {
                    return `Recommended: Good treatment option with acceptable risk profile`;
                } else if (mlScore > 0.4) {
                    return `Consider: Alternative treatment option, monitor response closely`;
                } else {
                    return `Caution: Consider only if other options unsuccessful, close monitoring required`;
                }
            }

            inferMechanismOfAction(treatment, condition) {
                const mechanisms = {
                    'triptans': 'Selective serotonin receptor agonists targeting migraine pathophysiology',
                    'analgesics': 'Pain pathway inhibition through COX enzyme blockade',
                    'pci': 'Mechanical restoration of coronary blood flow',
                    'antibiotics': 'Bacterial cell wall disruption and protein synthesis inhibition'
                };
                return mechanisms[treatment.id] || 'Targeted therapeutic intervention for condition management';
            }

            predictTreatmentTimeline(treatment, condition) {
                const timelines = {
                    'triptans': '30-120 minutes for migraine relief',
                    'analgesics': '30-60 minutes for pain relief',
                    'pci': 'Immediate reperfusion, 2-4 weeks recovery',
                    'antibiotics': '24-72 hours for clinical improvement'
                };
                return timelines[treatment.id] || 'Variable timeline based on individual response';
            }

            calculatePersonalizedRisk(treatment, condition) {
                let risk = treatment.sideEffects || 0.2;
                if (condition.severity === 'severe') risk *= 0.8;
                if (condition.chronicityRisk > 0.7) risk *= 0.9;
                return Math.max(0.05, Math.min(risk, 0.8));
            }

            calculateMLConfidence(treatment, condition) {
                let confidence = 0.7;
                const establishedTreatments = ['pci', 'antibiotics', 'analgesics', 'supportive_care'];
                if (establishedTreatments.includes(treatment.id)) confidence += 0.2;
                if ((condition.severity === 'severe' && treatment.efficacy > 0.8) ||
                    (condition.severity === 'mild' && treatment.sideEffects < 0.15)) {
                    confidence += 0.1;
                }
                return Math.min(confidence, 0.95);
            }

            runEnhancedSimulations(treatment, condition, numSimulations = 25) {
                const successValues = [];
                const costValues = [];
                const costBreakdown = { monetary: [], pain: [], emotional: [], social: [], time: [] };

                for (let i = 0; i < numSimulations; i++) {
                    const mlVariationFactor = 1 + (Math.random() - 0.5) * 0.2;
                    const personalizedFactor = treatment.mlConfidence || 0.7;
                    const conditionSeverityFactor = this.getSeverityFactor(condition.severity);

                    const baseSuccess = treatment.efficacy * personalizedFactor;
                    const adjustedSuccess = Math.max(0, Math.min(1, baseSuccess * mlVariationFactor * conditionSeverityFactor));
                    successValues.push(adjustedSuccess);

                    const baseCost = treatment.cost || 500;
                    const costVariation = baseCost * (1 + (Math.random() - 0.5) * 0.3);
                    costBreakdown.monetary.push(Math.max(0, costVariation));

                    const predictedPain = this.predictPainLevel(treatment, condition);
                    costBreakdown.pain.push(predictedPain * (1 + (Math.random() - 0.5) * 0.3));

                    const emotionalStress = this.predictEmotionalStress(treatment, condition);
                    costBreakdown.emotional.push(emotionalStress * (1 + (Math.random() - 0.5) * 0.25));

                    const socialImpact = this.predictSocialImpact(treatment, condition);
                    costBreakdown.social.push(socialImpact * (1 + (Math.random() - 0.5) * 0.2));

                    const timeCommitment = this.predictTimeCommitment(treatment, condition);
                    costBreakdown.time.push(timeCommitment * (1 + (Math.random() - 0.5) * 0.15));

                    const totalCost = costVariation + (predictedPain * 200) + (emotionalStress * 150) + (socialImpact * 100) + (timeCommitment * 50);
                    costValues.push(totalCost);
                }

                return {
                    success: this.calculateStatistics(successValues),
                    cost: this.calculateStatistics(costValues),
                    costBreakdown: {
                        monetary: this.calculateStatistics(costBreakdown.monetary),
                        pain: this.calculateStatistics(costBreakdown.pain),
                        emotional: this.calculateStatistics(costBreakdown.emotional),
                        social: this.calculateStatistics(costBreakdown.social),
                        time: this.calculateStatistics(costBreakdown.time)
                    }
                };
            }

            getSeverityFactor(severity) {
                const factors = { 'mild': 1.1, 'moderate': 1.0, 'severe': 0.9, 'critical': 0.8 };
                return factors[severity] || 1.0;
            }

            predictPainLevel(treatment, condition) {
                const baseMap = { 'appendectomy': 7, 'pci': 5, 'lithotripsy': 4, 'antibiotics': 0, 'supportive_care': 1 };
                let pain = baseMap[treatment.id] || 2;
                if (condition.severity === 'severe') pain *= 1.2;
                if (condition.severity === 'mild') pain *= 0.8;
                return Math.max(0, Math.min(10, pain));
            }

            predictEmotionalStress(treatment, condition) {
                let stress = 2;
                if (treatment.cost > 20000) stress += 3;
                if (treatment.efficacy < 0.6) stress += 2;
                if (condition.chronicityRisk > 0.7) stress += 2;
                if (condition.severity === 'severe') stress += 3;
                return Math.max(0, Math.min(10, stress));
            }

            predictSocialImpact(treatment, condition) {
                let impact = 1;
                if (['appendectomy', 'pci'].includes(treatment.id)) impact += 3;
                if (condition.chronicityRisk > 0.8) impact += 2;
                if (treatment.cost > 15000) impact += 1;
                return Math.max(0, Math.min(10, impact));
            }

            predictTimeCommitment(treatment, condition) {
                const timeMap = { 'appendectomy': 6, 'pci': 4, 'antibiotics': 1, 'supportive_care': 2 };
                let time = timeMap[treatment.id] || 2;
                if (condition.chronicityRisk > 0.7) time *= 2;
                return Math.max(0.5, time);
            }

            calculateStatistics(values) {
                if (!values || values.length === 0) {
                    return { mean: 0, se: 0, min: 0, max: 0, std: 0 };
                }
                
                const mean = values.reduce((a, b) => a + b, 0) / values.length;
                const variance = values.reduce((acc, val) => acc + Math.pow(val - mean, 2), 0) / values.length;
                const std = Math.sqrt(variance);
                const se = std / Math.sqrt(values.length);
                
                return { mean, se, min: Math.min(...values), max: Math.max(...values), std };
            }

            calculateOverallConfidence(symptoms, conditions) {
                if (symptoms.length === 0) return 0;
                const avgSymptomConfidence = symptoms.reduce((sum, s) => sum + s.confidence, 0) / symptoms.length;
                const conditionBonus = Math.min(conditions.length * 0.1, 0.3);
                const mlBonus = this.precomputedEmbeddings ? 0.25 : 0;
                return Math.min(avgSymptomConfidence + conditionBonus + mlBonus, 1.0);
            }

            buildClinicalWorkflow(symptoms, conditions, treatmentPaths) {
                let nodeId = 1;
                const nodes = [];
                
                conditions.forEach(condition => {
                    const conditionNode = {
                        id: nodeId++,
                        type: 'diagnosis',
                        title: condition.name.toUpperCase(),
                        description: `${condition.description} (ML Confidence: ${(condition.confidence * 100).toFixed(1)}%)`,
                        children: [],
                        metadata: condition
                    };
                    
                    const relevantTreatments = treatmentPaths.filter(tp => tp.condition.id === condition.id);
                    
                    relevantTreatments.forEach(treatmentPath => {
                        const treatmentNode = {
                            id: nodeId++,
                            type: 'treatment',
                            title: treatmentPath.treatment.name.toUpperCase(),
                            description: treatmentPath.recommendation,
                            children: [],
                            metadata: {
                                treatment: treatmentPath.treatment,
                                mlScore: treatmentPath.mlScore,
                                evidenceLevel: treatmentPath.evidenceLevel
                            }
                        };
                        
                        const outcomeNode = {
                            id: nodeId++,
                            type: 'outcome',
                            title: 'ML-Predicted Outcome',
                            description: this.generateOutcomeDescription(treatmentPath),
                            enhancedStatistics: treatmentPath.statistics,
                            metadata: {
                                mlPredictions: this.generateMLPredictions(treatmentPath),
                                riskAssessment: this.assessRisk(treatmentPath),
                                timeline: treatmentPath.treatment.expectedTimeline
                            }
                        };
                        
                        treatmentNode.children.push(outcomeNode);
                        conditionNode.children.push(treatmentNode);
                    });
                    
                    nodes.push(conditionNode);
                });
                
                return {
                    id: 'optimized_ml_workflow',
                    type: 'symptom_complex',
                    title: 'Optimized ML Clinical Analysis',
                    description: this.generateWorkflowDescription(symptoms, conditions),
                    children: nodes
                };
            }

            generateOutcomeDescription(treatmentPath) {
                const stats = treatmentPath.statistics;
                const treatment = treatmentPath.treatment;
                const successRate = (stats.success.mean * 100).toFixed(1);
                const costEstimate = Math.round(stats.cost.mean);
                const mlScore = (treatmentPath.mlScore * 100).toFixed(1);
                
                return `Optimized ML prediction: ${successRate}% success probability, estimated cost ${costEstimate}. ML treatment score: ${mlScore}%. ${treatment.expectedTimeline}`;
            }

            generateMLPredictions(treatmentPath) {
                return {
                    successProbability: treatmentPath.statistics.success.mean,
                    timeToImprovement: treatmentPath.treatment.expectedTimeline,
                    riskScore: treatmentPath.treatment.personalizedRisk,
                    costEffectiveness: this.calculateCostEffectiveness(treatmentPath),
                    qualityOfLifeImprovement: this.predictQOLImprovement(treatmentPath)
                };
            }

            calculateCostEffectiveness(treatmentPath) {
                const efficacy = treatmentPath.treatment.efficacy;
                const cost = treatmentPath.treatment.cost || 500;
                const costEffectiveness = efficacy / (cost / 1000);
                
                if (costEffectiveness > 0.8) return 'Excellent';
                if (costEffectiveness > 0.5) return 'Good';
                if (costEffectiveness > 0.3) return 'Fair';
                return 'Poor';
            }

            predictQOLImprovement(treatmentPath) {
                const efficacy = treatmentPath.treatment.efficacy;
                const sideEffects = treatmentPath.treatment.sideEffects;
                const chronicityRisk = treatmentPath.condition.chronicityRisk;
                
                let qolScore = efficacy * 100;
                qolScore -= sideEffects * 30;
                if (chronicityRisk > 0.7) qolScore -= 10;
                
                if (qolScore > 80) return 'Significant improvement expected';
                if (qolScore > 60) return 'Good improvement expected';
                if (qolScore > 40) return 'Moderate improvement expected';
                return 'Limited improvement expected';
            }

            assessRisk(treatmentPath) {
                const treatment = treatmentPath.treatment;
                const condition = treatmentPath.condition;
                const riskFactors = [];
                
                if (treatment.sideEffects > 0.3) riskFactors.push('High side effect risk');
                if (treatment.cost > 20000) riskFactors.push('High financial cost');
                if (condition.severity === 'severe') riskFactors.push('Severe underlying condition');
                
                return {
                    level: riskFactors.length > 2 ? 'High' : riskFactors.length > 0 ? 'Moderate' : 'Low',
                    factors: riskFactors,
                    recommendation: riskFactors.length > 2 ? 'Close monitoring required' : 'Standard monitoring adequate'
                };
            }

            generateWorkflowDescription(symptoms, conditions) {
                const symptomNames = symptoms.slice(0, 3).map(s => s.name).join(', ');
                const topCondition = conditions[0]?.name || 'Unknown condition';
                const embeddingSource = this.precomputedEmbeddings?.metadata?.version || 'fallback';
                
                return `Optimized ML Analysis: Detected ${symptoms.length} symptoms including ${symptomNames}. Primary differential diagnosis: ${topCondition}. Analysis powered by pre-computed embeddings (${embeddingSource}) and clinical knowledge integration.`;
            }

            createSampleHPOData() {
                return {
                    graphs: [{
                        nodes: [
                            {
                                id: "http://purl.obolibrary.org/obo/HP_0002315",
                                lbl: "Headache",
                                meta: {
                                    definition: { val: "Pain in the head or neck region" },
                                    synonyms: [{ val: "Head pain" }, { val: "Cephalgia" }]
                                }
                            },
                            {
                                id: "http://purl.obolibrary.org/obo/HP_0100749",
                                lbl: "Chest pain",
                                meta: {
                                    definition: { val: "Pain in the chest" },
                                    synonyms: [{ val: "Thoracic pain" }]
                                }
                            }
                        ]
                    }]
                };
            }

            createFallbackKB() {
                return {
                    conditions: {
                        'migraine': { name: 'Migraine', description: 'Recurrent headache disorder', severity: 'moderate_to_severe' },
                        'angina': { name: 'Angina', description: 'Chest pain due to reduced cardiac blood flow', severity: 'moderate_to_severe' }
                    },
                    treatments: {
                        'analgesics': { name: 'Pain Medications', efficacy: 0.8, cost: 50, sideEffects: 0.2 },
                        'supportive_care': { name: 'Supportive Care', efficacy: 0.7, cost: 200, sideEffects: 0.1 }
                    }
                };
            }

            async initializeFallbackMode() {
                console.log('ðŸ”„ Initializing fallback mode...');
                this.hpoData = this.createSampleHPOData();
                this.biomedicalKB = this.createFallbackKB();
                this.createFallbackEmbeddings();
            }
        }

        // Enhanced Clinical Display Components with Embedding Status
        const OptimizedMLAnalysisResults = ({ analysis }) => {
            const [expandedNodes, setExpandedNodes] = React.useState(new Set(['optimized_ml_workflow']));
            const [showMLMetrics, setShowMLMetrics] = React.useState(false);
            
            const toggleNode = (nodeId) => {
                const newExpanded = new Set(expandedNodes);
                if (newExpanded.has(nodeId)) {
                    newExpanded.delete(nodeId);
                } else {
                    newExpanded.add(nodeId);
                }
                setExpandedNodes(newExpanded);
            };

            const renderMLMetrics = () => {
                if (!analysis.mlMetrics) return null;
                
                return (
                    <div className="bg-gradient-to-r from-purple-50 to-blue-50 p-4 rounded-lg mb-4">
                        <div className="flex items-center justify-between mb-2">
                            <h3 className="font-medium text-purple-800 flex items-center gap-2">
                                <Cpu className="w-4 h-4" />
                                Optimized ML Performance
                            </h3>
                            <button
                                onClick={() => setShowMLMetrics(!showMLMetrics)}
                                className="text-xs bg-purple-200 text-purple-800 px-2 py-1 rounded hover:bg-purple-300"
                            >
                                {showMLMetrics ? 'Hide' : 'Show'} Details
                            </button>
                        </div>
                        
                        <div className="grid grid-cols-2 md:grid-cols-4 gap-3 text-xs mb-3">
                            <div className="bg-white p-2 rounded border">
                                <div className="flex items-center gap-1 text-green-600">
                                    <Zap className="w-3 h-3" />
                                    <span>Backend: {analysis.mlMetrics.backend}</span>
                                </div>
                            </div>
                            <div className="bg-white p-2 rounded border">
                                <div className="flex items-center gap-1 text-purple-600">
                                    <Layers className="w-3 h-3" />
                                    <span>Embeddings: {analysis.mlMetrics.precomputedEmbeddings?.toLocaleString() || 0}</span>
                                </div>
                            </div>
                            <div className="bg-white p-2 rounded border">
                                <div className="flex items-center gap-1 text-blue-600">
                                    <CloudDownload className="w-3 h-3" />
                                    <span>Source: {analysis.mlMetrics.embeddingSource}</span>
                                </div>
                            </div>
                            <div className="bg-white p-2 rounded border">
                                <div className="text-gray-600">
                                    Dimensions: {analysis.mlMetrics.embeddingDimensions}D
                                </div>
                            </div>
                        </div>

                        {showMLMetrics && (
                            <div className="grid grid-cols-2 md:grid-cols-3 gap-2 text-xs">
                                <div className="bg-white p-2 rounded border">
                                    <div className="text-gray-600">
                                        GPU Memory: {Math.round(analysis.mlMetrics.memory?.numBytesInGPU / 1024 / 1024 || 0)}MB
                                    </div>
                                </div>
                                <div className="bg-white p-2 rounded border">
                                    <div className="text-gray-600">
                                        Tensors: {analysis.mlMetrics.memory?.numTensors || 0}
                                    </div>
                                </div>
                                <div className="bg-white p-2 rounded border">
                                    <div className="text-gray-600">
                                        Memory Efficiency: Optimized
                                    </div>
                                </div>
                            </div>
                        )}
                    </div>
                );
            };

            const renderSemanticMatches = () => {
                if (!analysis.semanticMatches?.length) return null;
                
                return (
                    <div className="bg-indigo-50 p-4 rounded-lg">
                        <h3 className="font-medium text-indigo-800 mb-2 flex items-center gap-2">
                            <Brain className="w-4 h-4" />
                            Top Semantic Matches (Pre-computed Embeddings)
                        </h3>
                        <div className="space-y-1 max-h-32 overflow-y-auto">
                            {analysis.semanticMatches.slice(0, 8).map((match, index) => (
                                <div key={index} className="bg-indigo-100 p-2 rounded text-xs flex items-center justify-between">
                                    <span className="font-medium">{match.label.name}</span>
                                    <div className="flex gap-1">
                                        <span className="bg-indigo-200 px-2 py-1 rounded">
                                            {(match.similarity * 100).toFixed(1)}%
                                        </span>
                                        {match.label.type === 'hpo_term' && (
                                            <span className="bg-green-200 text-green-800 px-2 py-1 rounded text-xs">HPO</span>
                                        )}
                                    </div>
                                </div>
                            ))}
                        </div>
                    </div>
                );
            };

            const renderWorkflowNode = (node, level = 0) => {
                const isExpanded = expandedNodes.has(node.id);
                const nodeColors = {
                    symptom_complex: 'bg-gradient-to-r from-blue-100 to-blue-200 border-blue-400',
                    diagnosis: 'bg-gradient-to-r from-green-100 to-green-200 border-green-400',
                    treatment: 'bg-gradient-to-r from-purple-100 to-purple-200 border-purple-400',
                    outcome: 'bg-gradient-to-r from-orange-100 to-orange-200 border-orange-400'
                };
                
                const nodeIcons = {
                    symptom_complex: <Brain className="w-4 h-4" />,
                    diagnosis: <AlertCircle className="w-4 h-4" />,
                    treatment: <Activity className="w-4 h-4" />,
                    outcome: <TrendingUp className="w-4 h-4" />
                };

                return (
                    <div key={node.id} style={{ marginLeft: `${level * 20}px` }}>
                        <div className={`p-4 rounded-lg border-2 ${nodeColors[node.type]} mb-3 cursor-pointer transition-all hover:shadow-lg transform hover:scale-[1.02]`}
                             onClick={() => toggleNode(node.id)}>
                            <div className="flex items-center gap-3">
                                {nodeIcons[node.type]}
                                <span className="font-semibold text-lg">{node.title}</span>
                                {node.children && node.children.length > 0 && (
                                    <span className="text-xs bg-white px-3 py-1 rounded-full font-medium shadow">
                                        {isExpanded ? 'âˆ’' : '+'} {node.children.length}
                                    </span>
                                )}
                                {node.metadata?.mlScore && (
                                    <span className="text-xs bg-purple-500 text-white px-2 py-1 rounded-full">
                                        ML: {(node.metadata.mlScore * 100).toFixed(0)}%
                                    </span>
                                )}
                            </div>
                            
                            {node.description && (
                                <p className="text-sm text-gray-700 mt-2 leading-relaxed">{node.description}</p>
                            )}
                            
                            {node.enhancedStatistics && (
                                <div className="mt-4 space-y-3">
                                    <div className="bg-white p-3 rounded-lg border shadow-sm">
                                        <div className="flex items-center gap-2 text-sm font-semibold text-green-700 mb-2">
                                            <TrendingUp className="w-4 h-4" />
                                            Optimized ML Success Prediction
                                        </div>
                                        <div className="flex items-center gap-2">
                                            <div className="flex-1 bg-gray-200 rounded-full h-3">
                                                <div 
                                                    className="bg-gradient-to-r from-green-400 to-green-600 h-3 rounded-full transition-all duration-500"
                                                    style={{ width: `${node.enhancedStatistics.success.mean * 100}%` }}
                                                ></div>
                                            </div>
                                            <span className="text-sm font-bold">
                                                {(node.enhancedStatistics.success.mean * 100).toFixed(1)}% Â± {(node.enhancedStatistics.success.se * 100).toFixed(1)}%
                                            </span>
                                        </div>
                                    </div>
                                    
                                    <div className="bg-white p-3 rounded-lg border shadow-sm">
                                        <div className="text-xs font-semibold text-gray-700 mb-2">Comprehensive Impact Analysis</div>
                                        <div className="grid grid-cols-2 md:grid-cols-5 gap-2 text-xs">
                                            {Object.entries(node.enhancedStatistics.costBreakdown).map(([type, stats]) => (
                                                <div key={type} className="text-center">
                                                    <div className="flex items-center justify-center gap-1 mb-1">
                                                        {type === 'monetary' && <DollarSign className="w-3 h-3 text-green-600" />}
                                                        {type === 'pain' && <Thermometer className="w-3 h-3 text-red-600" />}
                                                        {type === 'emotional' && <Heart className="w-3 h-3 text-pink-600" />}
                                                        {type === 'social' && <Users className="w-3 h-3 text-blue-600" />}
                                                        {type === 'time' && <Clock className="w-3 h-3 text-purple-600" />}
                                                        <span className="capitalize font-medium">{type}</span>
                                                    </div>
                                                    <div className="text-sm font-bold">
                                                        {type === 'monetary' ? `${Math.round(stats.mean)}` : `${stats.mean.toFixed(1)}`}
                                                    </div>
                                                    <div className="text-xs text-gray-500">
                                                        Â±{type === 'monetary' ? `${Math.round(stats.se)}` : `${stats.se.toFixed(1)}`}
                                                    </div>
                                                </div>
                                            ))}
                                        </div>
                                    </div>
                                </div>
                            )}
                            
                            {node.metadata && (
                                <div className="mt-3 p-2 bg-white bg-opacity-70 rounded text-xs space-y-1">
                                    {node.metadata.evidenceLevel && (
                                        <div className="flex items-center gap-2">
                                            <span className="font-medium">Evidence:</span>
                                            <span className="bg-blue-100 text-blue-800 px-2 py-1 rounded">{node.metadata.evidenceLevel}</span>
                                        </div>
                                    )}
                                    {node.metadata.mlPredictions && (
                                        <div className="text-gray-600">
                                            ML Predictions: {node.metadata.mlPredictions.qualityOfLifeImprovement}
                                        </div>
                                    )}
                                    {node.metadata.riskAssessment && (
                                        <div className="flex items-center gap-2">
                                            <span className="font-medium">Risk Level:</span>
                                            <span className={`px-2 py-1 rounded text-xs ${
                                                node.metadata.riskAssessment.level === 'High' ? 'bg-red-100 text-red-800' :
                                                node.metadata.riskAssessment.level === 'Moderate' ? 'bg-yellow-100 text-yellow-800' :
                                                'bg-green-100 text-green-800'
                                            }`}>
                                                {node.metadata.riskAssessment.level}
                                            </span>
                                        </div>
                                    )}
                                </div>
                            )}
                        </div>
                        
                        {isExpanded && node.children && node.children.map(child => 
                            renderWorkflowNode(child, level + 1)
                        )}
                    </div>
                );
            };

            return (
                <div className="space-y-6">
                    {/* Optimized ML Performance Dashboard */}
                    {renderMLMetrics()}
                    
                    {/* Enhanced Clinical Summary */}
                    <div className="bg-white rounded-xl shadow-lg p-6">
                        <h2 className="text-2xl font-bold mb-4 flex items-center gap-3">
                            <div className="embedding-status w-3 h-3 rounded-full"></div>
                            <Brain className="w-6 h-6 text-blue-600" />
                            Optimized ML Clinical Analysis
                        </h2>
                        
                        <div className="grid grid-cols-1 lg:grid-cols-3 gap-6">
                            <div className="bg-blue-50 p-4 rounded-lg">
                                <h3 className="font-semibold text-blue-800 mb-3 flex items-center gap-2">
                                    <AlertCircle className="w-4 h-4" />
                                    Optimized Symptom Detection
                                </h3>
                                <div className="space-y-2">
                                    {analysis.symptoms.map((symptom, index) => (
                                        <div key={index} className="bg-blue-100 p-3 rounded-lg text-sm border border-blue-200">
                                            <div className="flex items-center justify-between mb-1">
                                                <span className="font-semibold capitalize">
                                                    {symptom.severity !== 'moderate' && `${symptom.severity} `}
                                                    {symptom.temporal !== 'acute' && `${symptom.temporal} `}
                                                    {symptom.name}
                                                </span>
                                                <div className="flex gap-1">
                                                    <span className="text-xs bg-blue-200 px-2 py-1 rounded">
                                                        {(symptom.confidence * 100).toFixed(0)}%
                                                    </span>
                                                    {symptom.source === 'ml_precomputed_matching' && (
                                                        <span className="text-xs bg-purple-200 text-purple-800 px-2 py-1 rounded">
                                                            Optimized
                                                        </span>
                                                    )}
                                                </div>
                                            </div>
                                            {symptom.hpoId && (
                                                <div className="text-xs text-blue-600">
                                                    HPO: {symptom.hpoId} | System: {symptom.anatomicalSystem}
                                                </div>
                                            )}
                                            {symptom.semanticSimilarity && (
                                                <div className="text-xs text-purple-600 mt-1">
                                                    Pre-computed similarity: {(symptom.semanticSimilarity * 100).toFixed(1)}%
                                                </div>
                                            )}
                                        </div>
                                    ))}
                                </div>
                            </div>
                            
                            <div className="bg-green-50 p-4 rounded-lg">
                                <h3 className="font-semibold text-green-800 mb-3 flex items-center gap-2">
                                    <Brain className="w-4 h-4" />
                                    Optimized Condition Mapping
                                </h3>
                                <div className="space-y-2">
                                    {analysis.conditions.map((condition, index) => (
                                        <div key={index} className="bg-green-100 p-3 rounded-lg text-sm border border-green-200">
                                            <div className="flex items-center justify-between mb-1">
                                                <span className="font-semibold">{condition.name}</span>
                                                <div className="flex gap-1">
                                                    <span className="text-xs bg-green-200 px-2 py-1 rounded">
                                                        {(condition.adjustedProbability * 100).toFixed(1)}%
                                                    </span>
                                                    {condition.source === 'ml_precomputed_mapping' && (
                                                        <span className="text-xs bg-purple-200 text-purple-800 px-2 py-1 rounded">
                                                            Optimized
                                                        </span>
                                                    )}
                                                </div>
                                            </div>
                                            <div className="text-xs text-green-600 leading-relaxed">
                                                {condition.description}
                                            </div>
                                            {condition.evidence?.[0] && (
                                                <div className="text-xs text-gray-600 mt-1">
                                                    Evidence: {condition.evidence[0].source}
                                                </div>
                                            )}
                                        </div>
                                    ))}
                                </div>
                            </div>

                            <div>
                                {renderSemanticMatches()}
                                
                                <div className="bg-purple-50 p-4 rounded-lg mt-4">
                                    <h3 className="font-semibold text-purple-800 mb-2">Optimized Analysis Confidence</h3>
                                    <div className="flex items-center gap-3">
                                        <div className="flex-1 bg-gray-200 rounded-full h-4">
                                            <div 
                                                className="bg-gradient-to-r from-purple-400 to-purple-600 h-4 rounded-full transition-all duration-500"
                                                style={{ width: `${analysis.confidence * 100}%` }}
                                            ></div>
                                        </div>
                                        <span className="text-sm font-bold">
                                            {(analysis.confidence * 100).toFixed(1)}%
                                        </span>
                                    </div>
                                    <div className="text-xs text-purple-600 mt-1">
                                        Enhanced with pre-computed neural embeddings
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                    
                    {/* Optimized Clinical Workflow */}
                    {analysis.workflow && (
                        <div className="bg-white rounded-xl shadow-lg p-6">
                            <h2 className="text-xl font-bold mb-4 flex items-center gap-2">
                                <Cpu className="w-5 h-5 text-purple-600" />
                                Optimized ML Clinical Decision Workflow
                            </h2>
                            
                            <div className="bg-gradient-to-r from-purple-50 to-blue-50 p-4 rounded-lg mb-6">
                                <h3 className="font-semibold text-gray-800 mb-2">Advanced Optimized Impact Analysis</h3>
                                <div className="grid grid-cols-2 md:grid-cols-5 gap-3 text-xs">
                                    <div className="flex items-center gap-1">
                                        <DollarSign className="w-3 h-3 text-green-600" />
                                        <span><strong>Financial:</strong> Direct medical costs</span>
                                    </div>
                                    <div className="flex items-center gap-1">
                                        <Thermometer className="w-3 h-3 text-red-600" />
                                        <span><strong>Physical:</strong> Pain and discomfort</span>
                                    </div>
                                    <div className="flex items-center gap-1">
                                        <Heart className="w-3 h-3 text-pink-600" />
                                        <span><strong>Emotional:</strong> Psychological burden</span>
                                    </div>
                                    <div className="flex items-center gap-1">
                                        <Users className="w-3 h-3 text-blue-600" />
                                        <span><strong>Social:</strong> Impact on relationships</span>
                                    </div>
                                    <div className="flex items-center gap-1">
                                        <Clock className="w-3 h-3 text-purple-600" />
                                        <span><strong>Temporal:</strong> Time investment</span>
                                    </div>
                                </div>
                                <div className="mt-2 text-xs text-gray-600">
                                    Powered by pre-computed embeddings and optimized TensorFlow.js operations
                                </div>
                            </div>
                            
                            <div className="max-h-[600px] overflow-y-auto">
                                {renderWorkflowNode(analysis.workflow)}
                            </div>
                        </div>
                    )}
                </div>
            );
        };

// Main Application Component with robust loading
// Fixed main application component with corrected state management
const OptimizedClinicalApp = () => {
    const [clinicalEngine] = React.useState(() => new OptimizedMLClinicalEngine());
    const [isReady, setIsReady] = React.useState(false);
    const [userInput, setUserInput] = React.useState('');
    const [analysis, setAnalysis] = React.useState(null);
    const [isAnalyzing, setIsAnalyzing] = React.useState(false);
    const [analysisProgress, setAnalysisProgress] = React.useState(0);
    const [loadingStatus, setLoadingStatus] = React.useState('Initializing...');
    const [loadingProgress, setLoadingProgress] = React.useState(0);
    const [hasLoadingError, setHasLoadingError] = React.useState(false);
    const [retryCount, setRetryCount] = React.useState(0);
    const [embeddingStats, setEmbeddingStats] = React.useState(null);

    React.useEffect(() => {
        let mounted = true;
        
        // Listen for loading progress events
        // Replace existing event listener
const handleLoadingProgress = (event) => {
    const status = event.detail.status;
    setLoadingStatus(status);
    
    // Smart progress mapping based on status keywords
    if (status.includes('Initializing')) setLoadingProgress(10);
    else if (status.includes('Loading Universal')) setLoadingProgress(30);
    else if (status.includes('Loading pre-computed')) setLoadingProgress(50);
    else if (status.includes('Processing embedding')) setLoadingProgress(70);
    else if (status.includes('Optimizing')) setLoadingProgress(85);
    else if (status.includes('Loaded') && status.includes('embeddings')) {
        setLoadingProgress(95);
        setHasLoadingError(false);
    }
};

        window.addEventListener('embeddings-loading-progress', handleLoadingProgress);

        const initializeEngine = async () => {
            try {
                setLoadingProgress(5);
                const success = await clinicalEngine.initialize();
                
                if (mounted) {
                    if (success) {
                        setIsReady(true);
                        setLoadingStatus('Ready');
                        setLoadingProgress(100);
                        
                        // FIXED: Check actual embedding status, not just success
                        const hasPrecomputedEmbeddings = clinicalEngine.precomputedEmbeddings && 
                            clinicalEngine.precomputedEmbeddings.metadata &&
                            !clinicalEngine.precomputedEmbeddings.metadata.version.includes('fallback');
                        
                        if (hasPrecomputedEmbeddings) {
                            setHasLoadingError(false);
                            setEmbeddingStats({
                                count: clinicalEngine.precomputedEmbeddings.embeddings.length,
                                dimension: clinicalEngine.precomputedEmbeddings.metadata.embeddingDimension,
                                version: clinicalEngine.precomputedEmbeddings.metadata.version,
                                timestamp: clinicalEngine.precomputedEmbeddings.metadata.timestamp
                            });
                            console.log('âœ… UI confirmed: Using pre-computed embeddings');
                        } else {
                            setHasLoadingError(true);
                            console.log('âš ï¸ UI confirmed: Using fallback embeddings');
                        }
                    } else {
                        setHasLoadingError(true);
                        setLoadingStatus('Initialization failed - basic mode only');
                        setLoadingProgress(100);
                        setIsReady(true);
                    }
                }
            } catch (error) {
                console.error('Initialization error:', error);
                if (mounted) {
                    setHasLoadingError(true);
                    setLoadingStatus('Error occurred - attempting recovery...');
                    
                    try {
                        await clinicalEngine.initializeFallbackMode();
                        setIsReady(true);
                        setLoadingStatus('Recovery successful - limited functionality');
                    } catch (fallbackError) {
                        setLoadingStatus('Critical error - manual retry required');
                        console.error('Fallback initialization failed:', fallbackError);
                    }
                }
            }
        };

        initializeEngine();

        return () => {
            mounted = false;
            window.removeEventListener('embeddings-loading-progress', handleLoadingProgress);
        };
    }, [clinicalEngine]);

// FIXED: Add method to check current embedding status
const getCurrentEmbeddingStatus = () => {
    if (!clinicalEngine.precomputedEmbeddings) {
        return { type: 'none', message: 'No embeddings loaded' };
    }
    
    const metadata = clinicalEngine.precomputedEmbeddings.metadata;
    const count = clinicalEngine.precomputedEmbeddings.embeddings.length;
    
    // Use count as primary indicator (precomputed should have >1000 embeddings)
    if (count < 1000 || 
        (metadata.version && metadata.version.includes('fallback'))) {
        return { 
            type: 'fallback', 
            message: `Fallback mode (${metadata?.version || 'generated'})`,
            count: count
        };
    } else {
        return { 
            type: 'precomputed', 
            message: `Pre-computed embeddings (${metadata?.version || 'v3'})`,
            count: count,
            dimension: metadata?.embeddingDimension || 512,
            generated: metadata?.timestamp || '2025-06-26'
        };
    }
};

    const handleRetry = async () => {
        setRetryCount(prev => prev + 1);
        setIsReady(false);
        setHasLoadingError(false);
        setLoadingProgress(0);
        setLoadingStatus('Retrying initialization...');
        
        // Reset the engine
        clinicalEngine.initialized = false;
        if (clinicalEngine.embeddingsTensor) {
            clinicalEngine.embeddingsTensor.dispose();
        }
        if (clinicalEngine.normalizedEmbeddingsTensor) {
            clinicalEngine.normalizedEmbeddingsTensor.dispose();
        }
        
        try {
            const success = await clinicalEngine.initialize();
            if (success) {
                // Re-check embedding status after retry
                const embeddingStatus = getCurrentEmbeddingStatus();
                setHasLoadingError(embeddingStatus.type !== 'precomputed');
                setIsReady(true);
                setLoadingStatus('Ready');
                setLoadingProgress(100);
            } else {
                setHasLoadingError(true);
                setIsReady(true);
            }
        } catch (error) {
            console.error('Retry failed:', error);
            setHasLoadingError(true);
            setLoadingStatus('Retry failed - using basic mode');
            setIsReady(true);
        }
    };

    const handleAnalysis = async () => {
        setIsAnalyzing(true);
        setAnalysisProgress(0);
        
        try {
            const steps = [
                'Preprocessing clinical text...',
                'Generating input embedding...',
                'Computing semantic similarities...',
                'Detecting symptoms with ML...',
                'Mapping conditions...',
                'Generating treatment pathways...',
                'Running simulations...',
                'Synthesizing clinical workflow...'
            ];
            
            for (let i = 0; i < steps.length; i++) {
                setLoadingStatus(steps[i]);
                setAnalysisProgress((i / steps.length) * 100);
                await new Promise(resolve => setTimeout(resolve, 200));
            }
            
            const result = await clinicalEngine.analyzeClinicalPresentation(userInput);
            setAnalysis(result);
            setAnalysisProgress(100);
            setLoadingStatus('Analysis complete');
            
        } catch (error) {
            console.error('Analysis error:', error);
            setLoadingStatus('Analysis failed - please try again');
            alert(`Analysis failed: ${error.message}. Please try with a simpler description or refresh the page.`);
        } finally {
            setIsAnalyzing(false);
        }
    };

    const exportResults = () => {
        if (!analysis) return;
        
        const embeddingStatus = getCurrentEmbeddingStatus();
        const results = {
            input: userInput,
            analysis: analysis,
            timestamp: new Date().toISOString(),
            version: '3.0-Optimized-ML-Fixed',
            mlMetrics: analysis.mlMetrics,
            embeddingStatus: embeddingStatus,
            loadingMode: embeddingStatus.type
        };
        
        const blob = new Blob([JSON.stringify(results, null, 2)], { type: 'application/json' });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = `clinical-analysis-${new Date().toISOString().split('T')[0]}.json`;
        a.click();
        URL.revokeObjectURL(url);
    };

    const sampleTexts = [
        "Patient presents with severe, throbbing headaches occurring every morning for the past 2 weeks, accompanied by nausea and sensitivity to light.",
        "45-year-old male complains of crushing chest pain that radiates to the left arm, occurring during physical exertion and relieved by rest.",
        "Patient reports severe right lower abdominal pain that started around the navel and moved to the right side, with nausea and fever.",
        "Patient experiencing severe flank pain that comes in waves, associated with nausea and blood in urine."
    ];

    const loadSampleText = (text) => {
        setUserInput(text);
    };

    // FIXED: Determine actual current status
    const currentEmbeddingStatus = isReady ? getCurrentEmbeddingStatus() : { type: 'loading' };
    const isActuallyUsingFallback = currentEmbeddingStatus.type === 'fallback';

    if (!isReady) {
        return (
            <div className="min-h-screen bg-gradient-to-br from-purple-50 via-blue-50 to-indigo-100 flex items-center justify-center">
                <div className="bg-white rounded-xl shadow-2xl p-8 max-w-lg mx-auto">
                    <div className="text-center">
                        <div className="flex items-center justify-center mb-4">
                            {hasLoadingError ? (
                                <AlertCircle className="w-8 h-8 text-orange-500 mr-3" />
                            ) : (
                                <div className="loading-spinner mr-3"></div>
                            )}
                            <Cpu className="w-8 h-8 text-purple-600" />
                        </div>
                        
                        <h2 className="text-2xl font-bold mb-3 bg-gradient-to-r from-purple-600 to-blue-600 bg-clip-text text-transparent">
                            {hasLoadingError ? 'Loading with Fallback' : 'Initializing Optimized ML Engine'}
                        </h2>
                        
                        <p className="text-gray-600 mb-4">{loadingStatus}</p>
                        
                        {loadingProgress > 0 && (
                            <div className="bg-gray-200 rounded-full h-3 mb-4">
                                <div 
                                    className="bg-gradient-to-r from-purple-500 to-blue-500 h-3 rounded-full transition-all duration-300"
                                    style={{ width: `${Math.min(loadingProgress, 100)}%` }}
                                ></div>
                            </div>
                        )}
                        
                        <div className="text-xs text-gray-500 space-y-1">
                            <div>â€¢ Loading TensorFlow.js WebGL backend</div>
                            <div>â€¢ Loading Universal Sentence Encoder</div>
                            <div>â€¢ Loading pre-computed embeddings (61,540 items)</div>
                            <div>â€¢ Setting up optimized similarity computation</div>
                        </div>
                    </div>
                </div>
            </div>
        );
    }

    return (
        <div className="min-h-screen bg-gradient-to-br from-purple-50 via-blue-50 to-indigo-100">
            {/* Enhanced Header with CORRECT Status Indicators */}
            <nav className="bg-white shadow-xl border-b-4 border-gradient-to-r from-purple-600 to-blue-600">
                <div className="max-w-7xl mx-auto px-6 py-4">
                    <div className="flex items-center justify-between">
                        <div className="flex items-center space-x-4">
                            <div className="w-12 h-12 flex items-center justify-center">
                                <img src="SOCR_Logo.png" alt="SOCR Logo" className="w-12 h-12 object-contain" />
                            </div>
                            <div>
                                <h1 className="text-2xl font-bold bg-gradient-to-r from-purple-600 to-blue-600 bg-clip-text text-transparent">
                                    CLNQ Gen-2B: Optimized ML Clinical AI
                                </h1>
                                <p className="text-sm text-gray-600">
                                    {isActuallyUsingFallback 
                                        ? 'Fallback Mode - Generated Embeddings' 
                                        : `Pre-computed Embeddings (${currentEmbeddingStatus.count?.toLocaleString() || 'Unknown'} items) + Real-time ML Analysis`
                                    }
                                </p>
                            </div>
                        </div>
                        <div className="flex items-center space-x-6">
                            <div className="flex items-center gap-2">
                                <div className={`w-3 h-3 rounded-full ${isActuallyUsingFallback ? 'bg-orange-400' : 'gpu-indicator'}`}></div>
                                <Cpu className="w-4 h-4 text-purple-500" />
                                <span className="text-sm text-purple-600 font-medium">
                                    {tf.getBackend() === 'webgl' ? 'WebGL Optimized' : 'CPU Mode'}
                                </span>
                            </div>
                            <div className="flex items-center gap-2">
                                <div className={`w-3 h-3 rounded-full ${isActuallyUsingFallback ? 'bg-orange-400' : 'embedding-status'}`}></div>
                                <Layers className="w-4 h-4 text-green-500" />
                                <span className="text-sm text-green-600">
                                    {isActuallyUsingFallback ? 'Generated Embeddings' : 'Pre-computed Embeddings'}
                                </span>
                            </div>
                            <a href="https://www.socr.umich.edu/" target="_blank" rel="noopener noreferrer" 
                               className="text-blue-600 hover:text-blue-800 transition-colors">
                                Visit SOCR.umich.edu
                            </a>
                        </div>
                    </div>
                </div>
            </nav>

            <div className="p-6">
                <div className="max-w-7xl mx-auto">
                    {/* FIXED: Status Banner - Only show for ACTUAL fallback mode */}
                    {isActuallyUsingFallback && (
                        <div className="bg-orange-50 border border-orange-200 rounded-xl p-4 mb-6">
                            <div className="flex items-center gap-3">
                                <AlertCircle className="w-5 h-5 text-orange-600" />
                                <div>
                                    <h3 className="font-semibold text-orange-800">Fallback Mode Active</h3>
                                    <p className="text-sm text-orange-700">
                                        The app is running with generated embeddings instead of pre-computed ones. 
                                        Analysis will still work but may be less accurate.
                                        {retryCount < 2 && (
                                            <button 
                                                onClick={handleRetry}
                                                className="ml-2 underline hover:no-underline"
                                            >
                                                Try reloading embeddings
                                            </button>
                                        )}
                                    </p>
                                </div>
                            </div>
                        </div>
                    )}

                    {/* SUCCESS: Status Banner for Pre-computed Embeddings */}
                    {!isActuallyUsingFallback && currentEmbeddingStatus.type === 'precomputed' && (
                        <div className="bg-green-50 border border-green-200 rounded-xl p-4 mb-6">
                            <div className="flex items-center gap-3">
                                <Layers className="w-5 h-5 text-green-600" />
                                <div>
                                    <h3 className="font-semibold text-green-800">Pre-computed Embeddings Loaded Successfully</h3>
                                    <p className="text-sm text-green-700">
                                        Using {currentEmbeddingStatus.count?.toLocaleString()} pre-computed clinical embeddings 
                                        ({currentEmbeddingStatus.dimension}D) for optimized similarity computation.
                                        Generated: {new Date(currentEmbeddingStatus.generated).toLocaleDateString()}
                                    </p>
                                </div>
                            </div>
                        </div>
                    )}

                    {/* Enhanced Introduction */}
                    <div className="bg-white rounded-xl shadow-lg p-6 mb-6 border border-purple-100">
                        <h1 className="text-3xl font-bold bg-gradient-to-r from-purple-600 to-blue-600 bg-clip-text text-transparent mb-2">
                            Optimized ML Clinical Decision Support System
                        </h1>
                        <p className="text-gray-600 mb-4">
                            {isActuallyUsingFallback 
                                ? 'Clinical analysis with generated embeddings - reduced but functional capability'
                                : 'Lightning-fast clinical analysis powered by pre-computed embeddings and optimized TensorFlow.js operations'
                            }
                        </p>
                        <div className="flex flex-wrap gap-2 mb-4 text-sm">
                            <span className="bg-purple-100 text-purple-800 px-3 py-1 rounded-full flex items-center gap-1">
                                <Cpu className="w-3 h-3" />
                                TensorFlow.js {tf.getBackend().toUpperCase()}
                            </span>
                            <span className={`px-3 py-1 rounded-full flex items-center gap-1 ${
                                isActuallyUsingFallback 
                                    ? 'bg-orange-100 text-orange-800' 
                                    : 'bg-blue-100 text-blue-800'
                            }`}>
                                <Layers className="w-3 h-3" />
                                {isActuallyUsingFallback ? 'Generated Embeddings' : `Pre-computed (${currentEmbeddingStatus.count?.toLocaleString()})`}
                            </span>
                            <span className="bg-green-100 text-green-800 px-3 py-1 rounded-full">
                                {isActuallyUsingFallback ? 'Standard Similarity' : 'Optimized Similarity'}
                            </span>
                            <span className="bg-orange-100 text-orange-800 px-3 py-1 rounded-full">HPO Integration</span>
                            <span className="bg-pink-100 text-pink-800 px-3 py-1 rounded-full">Real-time Analysis</span>
                        </div>
                        
                        <div className="bg-gradient-to-r from-purple-50 to-blue-50 p-4 rounded-lg">
                            <h3 className="font-semibold text-gray-800 mb-2">
                                {isActuallyUsingFallback ? 'Fallback Mode Features:' : 'Optimization Features:'}
                            </h3>
                            <ul className="text-sm text-gray-700 space-y-1">
                                {isActuallyUsingFallback ? (
                                    <>
                                        <li>â€¢ Generated clinical embeddings for basic similarity matching</li>
                                        <li>â€¢ Rule-based symptom detection with ML enhancement</li>
                                        <li>â€¢ Standard tensor operations with available backend</li>
                                        <li>â€¢ Basic clinical decision support workflow</li>
                                        <li>â€¢ Reduced but functional analysis capabilities</li>
                                    </>
                                ) : (
                                    <>
                                        <li>â€¢ Pre-computed clinical embeddings ({currentEmbeddingStatus.count?.toLocaleString()} items) for instant similarity matching</li>
                                        <li>â€¢ Optimized tensor operations with WebGL acceleration</li>
                                        <li>â€¢ Memory-efficient processing with automatic cleanup</li>
                                        <li>â€¢ Intelligent filtering and context-aware analysis</li>
                                        <li>â€¢ Sub-second analysis for real-time clinical decision support</li>
                                    </>
                                )}
                            </ul>
                        </div>
                    </div>

                    {/* Input Section */}
                    <div className="bg-white rounded-xl shadow-lg p-6 mb-6 border border-blue-100">
                        <h2 className="text-xl font-semibold mb-4 flex items-center gap-2">
                            <Brain className="w-5 h-5 text-blue-600" />
                            Clinical Presentation Analysis
                        </h2>
                        
                        <div className="mb-4">
                            <label className="block text-sm font-medium text-gray-700 mb-2">
                                Clinical Presentation Description
                            </label>
                            <textarea
                                value={userInput}
                                onChange={(e) => setUserInput(e.target.value)}
                                placeholder={`Describe the clinical presentation. The ${isActuallyUsingFallback ? 'fallback' : 'optimized'} ML engine will provide analysis...`}
                                className="w-full h-32 p-4 border border-gray-300 rounded-lg resize-none focus:outline-none focus:ring-2 focus:ring-purple-500 focus:border-transparent transition-all"
                            />
                        </div>
                        
                        <div className="mb-4">
                            <h3 className="text-sm font-medium text-gray-700 mb-2">Sample Clinical Presentations:</h3>
                            <div className="grid grid-cols-1 md:grid-cols-2 gap-2">
                                {sampleTexts.map((text, index) => (
                                    <button
                                        key={index}
                                        onClick={() => loadSampleText(text)}
                                        className="text-left p-3 bg-gray-50 hover:bg-gray-100 rounded-lg text-sm border border-gray-200 transition-colors"
                                    >
                                        {text.substring(0, 80)}...
                                    </button>
                                ))}
                            </div>
                        </div>
                        
                        <div className="flex gap-4">
                            <button
                                onClick={handleAnalysis}
                                disabled={!userInput.trim() || isAnalyzing}
                                className="flex items-center gap-2 bg-gradient-to-r from-purple-600 to-blue-600 text-white px-6 py-3 rounded-lg hover:from-purple-700 hover:to-blue-700 disabled:opacity-50 disabled:cursor-not-allowed transition-all transform hover:scale-105"
                            >
                                {isAnalyzing ? (
                                    <>
                                        <div className="loading-spinner w-4 h-4"></div>
                                        {isActuallyUsingFallback ? 'Fallback Analysis...' : 'Optimized Analysis...'}
                                    </>
                                ) : (
                                    <>
                                        <Zap className="w-4 h-4" />
                                        {isActuallyUsingFallback ? 'Start Analysis' : 'Instant ML Analysis'}
                                    </>
                                )}
                            </button>
                            {analysis && (
                                <button
                                    onClick={exportResults}
                                    className="flex items-center gap-2 bg-green-600 text-white px-6 py-3 rounded-lg hover:bg-green-700 transition-all transform hover:scale-105"
                                >
                                    <Download className="w-4 h-4" />
                                    Export Results
                                </button>
                            )}
                        </div>
                        
                        {isAnalyzing && (
                            <div className="mt-4">
                                <div className="bg-gradient-to-r from-purple-200 to-blue-200 rounded-full h-3">
                                    <div 
                                        className="bg-gradient-to-r from-purple-600 to-blue-600 h-3 rounded-full transition-all duration-500"
                                        style={{ width: `${analysisProgress}%` }}
                                    ></div>
                                </div>
                                <p className="text-sm text-gray-600 mt-2 flex items-center gap-2">
                                    <Cpu className="w-4 h-4 text-purple-600" />
                                    {loadingStatus}
                                </p>
                            </div>
                        )}
                    </div>

                    {/* Results Section */}
                    {analysis && (
                        <OptimizedMLAnalysisResults analysis={analysis} />
                    )}
                </div>
            </div>

            {/* Footer with correct status */}
            <footer className="bg-gray-900 text-white mt-12">
                <div className="max-w-7xl mx-auto px-6 py-8">
                    <div className="grid grid-cols-1 md:grid-cols-4 gap-8">
                        <div>
                            <div className="flex items-center space-x-3 mb-4">
                                <div className="w-12 h-12 flex items-center justify-center">
                                    <img src="SOCR_Logo.png" alt="SOCR Logo" className="w-12 h-12 object-contain" />
                                </div>
                                <div>
                                    <h3 className="text-lg font-semibold">SOCR Clinical AI</h3>
                                    <p className="text-sm text-gray-300">
                                        {isActuallyUsingFallback ? 'Fallback Mode' : 'Pre-computed Embeddings Mode'}
                                    </p>
                                </div>
                            </div>
                            <p className="text-gray-300 text-sm">
                                {isActuallyUsingFallback 
                                    ? 'Clinical decision support with generated embeddings and fallback processing.'
                                    : `Ultra-fast clinical decision support powered by ${currentEmbeddingStatus.count?.toLocaleString()} pre-computed neural embeddings.`
                                }
                            </p>
                        </div>
                        
                        <div>
                            <h4 className="text-lg font-semibold mb-4">Current Status</h4>
                            <ul className="space-y-2 text-sm text-gray-300">
                                <li>â€¢ Backend: {tf.getBackend().toUpperCase()}</li>
                                <li>â€¢ Embeddings: {isActuallyUsingFallback ? 'Generated' : `Pre-computed (${currentEmbeddingStatus.count?.toLocaleString()})`}</li>
                                <li>â€¢ Mode: {isActuallyUsingFallback ? 'Fallback' : 'Optimized'}</li>
                                <li>â€¢ Processing: {isActuallyUsingFallback ? 'Standard' : 'Accelerated'}</li>
                                <li>â€¢ Memory Management: Active</li>
                            </ul>
                        </div>
                        
                        <div>
                            <h4 className="text-lg font-semibold mb-4">CLNQ Evolution</h4>
                            <ul className="space-y-2 text-sm">
                                <li>
                                    <a href="https://socr.umich.edu/GAIM/SOCR_CLNQ_0.html" target="_blank" rel="noopener noreferrer" className="text-blue-400 hover:text-blue-300 transition-colors">
                                        CLNQ Gen-0: Basic Analysis
                                    </a>
                                </li>
                                <li>
                                    <a href="https://socr.umich.edu/GAIM/SOCR_CLNQ_1.html" target="_blank" rel="noopener noreferrer" className="text-blue-400 hover:text-blue-300 transition-colors">
                                        CLNQ Gen-1: Enhanced KB
                                    </a>
                                </li>
                                <li>
                                    <span className="text-purple-400 font-semibold">CLNQ Gen-2: Extended (Previous)</span>
                                </li>
                                <li>
                                    <span className="text-yellow-400 font-semibold">CLNQ Gen-3: Optimized ML (Current)</span>
                                </li>
                                <li>
                                    <a href="https://clinique.statisticalcomputing.org/" target="_blank" rel="noopener noreferrer" className="text-blue-400 hover:text-blue-300 transition-colors">
                                        CLNQ Gen-4: Advanced
                                    </a>
                                </li>
                            </ul>
                        </div>
                        
                        <div>
                            <h4 className="text-lg font-semibold mb-4">Resources</h4>
                            <ul className="space-y-2 text-sm">
                                <li>
                                    <a href="App1_CLNQ_2B_EmbeddingsPrecomputer.html" className="text-green-400 hover:text-green-300 transition-colors">
                                        ðŸ”§ Embedding Precomputer Tool
                                    </a>
                                </li>
                                <li>
                                    <a href="https://www.tensorflow.org/js" target="_blank" rel="noopener noreferrer" className="text-blue-400 hover:text-blue-300 transition-colors">
                                        TensorFlow.js Docs
                                    </a>
                                </li>
                                <li>
                                    <a href="https://hpo.jax.org/" target="_blank" rel="noopener noreferrer" className="text-blue-400 hover:text-blue-300 transition-colors">
                                        HPO Ontology
                                    </a>
                                </li>
                                <li>
                                    <a href="https://github.com/SOCR" target="_blank" rel="noopener noreferrer" className="text-blue-400 hover:text-blue-300 transition-colors">
                                        SOCR GitHub
                                    </a>
                                </li>
                            </ul>
                        </div>
                    </div>
                    
                    <div className="border-t border-gray-700 mt-8 pt-6 flex flex-col md:flex-row justify-between items-center">
                        <div className="text-sm text-gray-400 flex items-center gap-2">
                            <Cpu className="w-4 h-4" />
                            Â© 2025 SOCR - University of Michigan. Optimized ML Clinical AI v3.0 
                            {isActuallyUsingFallback && ' (Fallback Mode)'}
                        </div>
                        <div className="text-sm text-gray-400 mt-2 md:mt-0">
                            <strong>Clinical Disclaimer:</strong> Educational tool for research. Always consult healthcare professionals.
                        </div>
                    </div>
                </div>
            </footer>
        </div>
    );
};


        const root = ReactDOM.createRoot(document.getElementById('root'));
        root.render(<OptimizedClinicalApp />);
    </script>

    <!-- Analytics and Tracking Scripts -->
    <script type="text/javascript">
        var sc_project = 5714596;
        var sc_invisible = 1;
        var sc_security = "038e9ac4";
        var scJsHost = (("https:" == document.location.protocol) ? "https://secure." : "https://www.");
        document.write("<sc"+"ript type='text/javascript' src='" + scJsHost + "statcounter.com/counter/counter.js'></"+"script>");
    </script>
    <noscript>
        <div class="statcounter">
            <a title="web analytics" href="https://statcounter.com/" target="_blank">
                <img class="statcounter" src="//c.statcounter.com/5714596/0/038e9ac4/1/" alt="web analytics">
            </a>
        </div>
    </noscript>

    <script src="https://www.google-analytics.com/urchin.js" type="text/javascript"></script>
    <script type="text/javascript">
        _uacct = "UA-676559-1";
        urchinTracker();
    </script>
    
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-69710121-1"></script>
    <script>
        window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());
        gtag('config', 'UA-69710121-1');
    </script>
</body>
</html>