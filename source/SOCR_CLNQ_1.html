<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>SOCR CLNQ: Clinical Decision Support System</title>
    <link rel="icon" type="image/png" href="SOCR_Logo.png">
    <script src="https://unpkg.com/react@18/umd/react.development.js"></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        .lucide { width: 1rem; height: 1rem; stroke: currentColor; stroke-width: 2; fill: none; }
        .loading-spinner {
            border: 3px solid #f3f3f3;
            border-top: 3px solid #3498db;
            border-radius: 50%;
            width: 20px;
            height: 20px;
            animation: spin 1s linear infinite;
        }
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
    </style>
</head>
<body>
    <div id="root"></div>
    
<script type="text/babel">
        // Icons
        const AlertCircle = () => <svg className="lucide"><circle cx="12" cy="12" r="10"/><line x1="12" y1="8" x2="12" y2="12"/><line x1="12" y1="16" x2="12.01" y2="16"/></svg>;
        const Activity = () => <svg className="lucide"><polyline points="22,12 18,12 15,21 9,3 6,12 2,12"/></svg>;
        const TrendingUp = () => <svg className="lucide"><polyline points="23,6 13.5,15.5 8.5,10.5 1,18"/><polyline points="17,6 23,6 23,12"/></svg>;
        const DollarSign = () => <svg className="lucide"><line x1="12" y1="1" x2="12" y2="23"/><path d="M17 5H9.5a3.5 3.5 0 0 0 0 7h5a3.5 3.5 0 0 1 0 7H6"/></svg>;
        const Brain = () => <svg className="lucide"><path d="M9.5 2A2.5 2.5 0 0 1 12 4.5v15a2.5 2.5 0 0 1-4.96.44 2.5 2.5 0 0 1-2.96-3.08 3 3 0 0 1-.34-5.58 2.5 2.5 0 0 1 1.32-4.24 2.5 2.5 0 0 1 1.98-3A2.5 2.5 0 0 1 9.5 2Z"/></svg>;
        const Heart = () => <svg className="lucide"><path d="M20.84 4.61a5.5 5.5 0 0 0-7.78 0L12 5.67l-1.06-1.06a5.5 5.5 0 0 0-7.78 7.78l1.06 1.06L12 21.23l7.78-7.78 1.06-1.06a5.5 5.5 0 0 0 0-7.78z"/></svg>;
        const Users = () => <svg className="lucide"><path d="M16 21v-2a4 4 0 0 0-4-4H6a4 4 0 0 0-4 4v2"/><circle cx="9" cy="7" r="4"/></svg>;
        const Clock = () => <svg className="lucide"><circle cx="12" cy="12" r="10"/><polyline points="12,6 12,12 16,14"/></svg>;
        const Thermometer = () => <svg className="lucide"><path d="M14 4v10.54a4 4 0 1 1-4 0V4a2 2 0 0 1 4 0Z"/></svg>;
        const Database = () => <svg className="lucide"><ellipse cx="12" cy="5" rx="9" ry="3"/><path d="M3 5v14a9 3 0 0 0 18 0V5"/><path d="M3 12a9 3 0 0 0 18 0"/></svg>;
        const Download = () => <svg className="lucide"><path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"/><polyline points="7,10 12,15 17,10"/><line x1="12" y1="15" x2="12" y2="3"/></svg>;
        const Play = () => <svg className="lucide"><polygon points="5,3 19,12 5,21"/></svg>;
        const Pause = () => <svg className="lucide"><rect x="6" y="4" width="4" height="16"/><rect x="14" y="4" width="4" height="16"/></svg>;
        const ChevronDown = () => <svg className="lucide"><polyline points="6,9 12,15 18,9"/></svg>;
        const ChevronRight = () => <svg className="lucide"><polyline points="9,18 15,12 9,6"/></svg>;

        // Enhanced Knowledge Service that prioritizes clinical coherence over data complexity

// Scientific HPO-Based Symptom Detection System
class ScientificSymptomDetector {
    constructor(hpoData, biomedicalKB) {
        this.hpoData = hpoData;
        this.biomedicalKB = biomedicalKB;
        
        // Build sophisticated medical knowledge structures
        this.hpoOntologyGraph = this.buildHPOOntologyGraph();
        this.medicalSemanticIndex = this.buildMedicalSemanticIndex();
        this.anatomySystemMap = this.buildAnatomicalSystemMap();
        this.clinicalConceptNetwork = this.buildClinicalConceptNetwork();
        
        console.log(`Scientific detector initialized with ${this.hpoOntologyGraph.size} HPO concepts`);
    }

    // ===== CORE SCIENTIFIC DETECTION METHOD =====
    
    detectSymptoms(text) {
        console.log('=== Scientific HPO-Based Symptom Detection ===');
        console.log('Input text:', text);
        
        const detectedSymptoms = [];
        const clinicalContext = this.extractClinicalContext(text);
        
        // Stage 1: Medical Entity Recognition using NLP-inspired techniques
        const medicalEntities = this.extractMedicalEntities(text);
        console.log('Extracted medical entities:', medicalEntities);
        
        // Stage 2: HPO Ontology-Based Semantic Matching
        const hpoMatches = this.performOntologyBasedMatching(medicalEntities, text);
        console.log('HPO ontology matches:', hpoMatches.length);
        
        // Stage 3: Clinical Context Validation and Scoring
        const validatedSymptoms = this.validateClinicalCoherence(hpoMatches, clinicalContext);
        console.log('Clinically validated symptoms:', validatedSymptoms.length);
        
        // Stage 4: Medical Knowledge Graph Enhancement
        const enhancedSymptoms = this.enhanceWithMedicalKnowledge(validatedSymptoms, text);
        
        return enhancedSymptoms
            .sort((a, b) => b.scientificConfidence - a.scientificConfidence)
            .slice(0, 8);
    }

    // ===== STAGE 1: MEDICAL ENTITY RECOGNITION =====
    
    extractMedicalEntities(text) {
        const entities = [];
        const words = text.toLowerCase().split(/\s+/);
        
        // Medical terminology patterns based on morphology
        const medicalMorphemes = {
            prefixes: ['hyper', 'hypo', 'dys', 'a', 'an', 'brady', 'tachy', 'hemi', 'para', 'quadri'],
            roots: ['card', 'neur', 'gastr', 'hepat', 'nephr', 'pulm', 'derm', 'ophthalm', 'oto', 'rhin'],
            suffixes: ['ia', 'osis', 'itis', 'algia', 'pathy', 'trophy', 'plasia', 'phasia', 'plegia', 'paresis']
        };
        
        // Extract compound medical terms
        for (let i = 0; i < words.length; i++) {
            const word = words[i];
            
            // Single medical terms
            if (this.isMedicalTerm(word)) {
                entities.push({
                    term: word,
                    type: 'medical_term',
                    position: i,
                    confidence: 0.8
                });
            }
            
            // Multi-word medical phrases (2-4 words)
            for (let j = 2; j <= Math.min(4, words.length - i); j++) {
                const phrase = words.slice(i, i + j).join(' ');
                if (this.isMedicalPhrase(phrase)) {
                    entities.push({
                        term: phrase,
                        type: 'medical_phrase',
                        position: i,
                        span: j,
                        confidence: 0.9
                    });
                }
            }
        }
        
        // Clinical presentation patterns
        const clinicalPatterns = [
            /(?:patient|pt)\s+(?:presents?|has|with|experiencing|suffering)\s+([^.!?]+)/gi,
            /(?:symptoms?|signs?)\s+(?:of|include|are)\s+([^.!?]+)/gi,
            /(?:complain(?:s|ing)?|report(?:s|ing)?)\s+(?:of)?\s+([^.!?]+)/gi
        ];
        
        clinicalPatterns.forEach(pattern => {
            let match;
            while ((match = pattern.exec(text)) !== null) {
                const clinicalPhrase = match[1].trim();
                entities.push({
                    term: clinicalPhrase,
                    type: 'clinical_presentation',
                    position: match.index,
                    confidence: 0.95,
                    context: 'patient_presentation'
                });
            }
        });
        
        return this.deduplicateEntities(entities);
    }
    
    isMedicalTerm(word) {
        // Medical term validation using morphological analysis
        const medicalIndicators = [
            /\b(stroke|seizure|paralysis|weakness|numbness|stiffness|tremor|ataxia)\b/,
            /\b(pain|ache|uria|pnea|algia|itis|osis|pathy|trophy|phasia|plegia)\b/,
            /\b(cardio|neuro|gastro|hepato|nephro|pulmo|dermo|ophthalmo)\w*/,
            /\b\w*(emia|osis|itis|algia|pathy|trophy|plasia|phasia|plegia|paresis)\b/
        ];
        
        return medicalIndicators.some(pattern => pattern.test(word)) && word.length > 3;
    }
    
    isMedicalPhrase(phrase) {
        // Medical phrase patterns
        const medicalPhrases = [
            /\b(left|right|bilateral|unilateral)\s+(side|sided|weakness|paralysis|numbness)\b/,
            /\b(motor|sensory|cognitive|visual|auditory)\s+(deficit|loss|impairment|dysfunction)\b/,
            /\b(loss\s+of|difficulty\s+with|problems\s+with|inability\s+to)\b/,
            /\b(acute|chronic|sudden|gradual|progressive|severe|mild|moderate)\s+\w+/,
            /\b\w+\s+(pain|syndrome|disease|disorder|condition|symptoms?)\b/
        ];
        
        return medicalPhrases.some(pattern => pattern.test(phrase));
    }
    
    deduplicateEntities(entities) {
        const seen = new Set();
        return entities.filter(entity => {
            const key = `${entity.term}_${entity.type}`;
            if (seen.has(key)) return false;
            seen.add(key);
            return true;
        });
    }

    // ===== STAGE 2: HPO ONTOLOGY-BASED SEMANTIC MATCHING =====
    
    performOntologyBasedMatching(entities, text) {
        const matches = [];
        
        entities.forEach(entity => {
            // Direct HPO concept matching
            const directMatches = this.findDirectHPOMatches(entity);
            matches.push(...directMatches);
            
            // Semantic similarity using HPO relationships
            const semanticMatches = this.findSemanticHPOMatches(entity, text);
            matches.push(...semanticMatches);
            
            // Anatomical system-based matching
            const anatomicalMatches = this.findAnatomicalHPOMatches(entity);
            matches.push(...anatomicalMatches);
        });
        
        return this.rankAndFilterMatches(matches);
    }
    
    findDirectHPOMatches(entity) {
        const matches = [];
        
        if (!this.hpoData?.graphs?.[0]?.nodes) return matches;
        
        this.hpoData.graphs[0].nodes.forEach(node => {
            const hpoId = node.id.replace('http://purl.obolibrary.org/obo/', '');
            const name = (node.lbl || node.label || '').toLowerCase();
            const definition = node.meta?.definition?.val || '';
            const synonyms = node.meta?.synonyms?.map(s => s.val.toLowerCase()) || [];
            
            if (!name) return;
            
            // Calculate semantic similarity using multiple metrics
            const nameScore = this.calculateSemanticSimilarity(entity.term, name);
            let bestScore = nameScore;
            let bestMatch = name;
            
            // Check synonyms
            synonyms.forEach(synonym => {
                const synScore = this.calculateSemanticSimilarity(entity.term, synonym);
                if (synScore > bestScore) {
                    bestScore = synScore;
                    bestMatch = synonym;
                }
            });
            
            // Definition-based matching for complex terms
            if (definition && entity.type === 'clinical_presentation') {
                const defScore = this.calculateDefinitionSimilarity(entity.term, definition);
                if (defScore > bestScore) {
                    bestScore = defScore;
                    bestMatch = `definition: ${definition.substring(0, 50)}...`;
                }
            }
            
            // Only accept high-confidence matches
            if (bestScore > 0.7) {
                const anatomicalSystem = this.identifyAnatomicalSystem(name, definition);
                const clinicalSignificance = this.calculateClinicalSignificance(node);
                
                matches.push({
                    hpoId,
                    name,
                    definition,
                    synonyms,
                    entity,
                    matchScore: bestScore,
                    matchedTerm: bestMatch,
                    anatomicalSystem,
                    clinicalSignificance,
                    ontologyDepth: this.calculateOntologyDepth(hpoId)
                });
            }
        });
        
        return matches;
    }
    
    calculateSemanticSimilarity(term1, term2) {
        // Advanced semantic similarity using multiple metrics
        const normalizedTerm1 = this.normalizemedicalTerm(term1);
        const normalizedTerm2 = this.normalizemedicalTerm(term2);
        
        // Exact match
        if (normalizedTerm1 === normalizedTerm2) return 1.0;
        
        // Jaccard similarity for word sets
        const words1 = new Set(normalizedTerm1.split(/\s+/));
        const words2 = new Set(normalizedTerm2.split(/\s+/));
        const intersection = new Set([...words1].filter(x => words2.has(x)));
        const union = new Set([...words1, ...words2]);
        const jaccardScore = intersection.size / union.size;
        
        // Edit distance for string similarity
        const editDistance = this.calculateEditDistance(normalizedTerm1, normalizedTerm2);
        const maxLength = Math.max(normalizedTerm1.length, normalizedTerm2.length);
        const editScore = maxLength > 0 ? 1 - (editDistance / maxLength) : 0;
        
        // Medical morpheme similarity
        const morphemeScore = this.calculateMorphemeSimilarity(term1, term2);
        
        // Weighted combination
        return (jaccardScore * 0.4) + (editScore * 0.3) + (morphemeScore * 0.3);
    }
    
    calculateMorphemeSimilarity(term1, term2) {
        // Extract medical morphemes and compare
        const morphemes1 = this.extractMedicalMorphemes(term1);
        const morphemes2 = this.extractMedicalMorphemes(term2);
        
        if (morphemes1.length === 0 && morphemes2.length === 0) return 0;
        
        const commonMorphemes = morphemes1.filter(m => morphemes2.includes(m));
        const totalMorphemes = new Set([...morphemes1, ...morphemes2]).size;
        
        return totalMorphemes > 0 ? commonMorphemes.length / totalMorphemes : 0;
    }
    
    extractMedicalMorphemes(term) {
        const morphemes = [];
        const medicalParts = [
            'cardio', 'neuro', 'gastro', 'hepato', 'nephro', 'pulmo', 'dermo', 'ophthalmo',
            'algia', 'itis', 'osis', 'pathy', 'trophy', 'plasia', 'phasia', 'plegia', 'paresis',
            'hyper', 'hypo', 'dys', 'brady', 'tachy', 'hemi', 'para'
        ];
        
        medicalParts.forEach(part => {
            if (term.toLowerCase().includes(part)) {
                morphemes.push(part);
            }
        });
        
        return morphemes;
    }

    // ===== STAGE 3: CLINICAL CONTEXT VALIDATION =====
    
    validateClinicalCoherence(matches, clinicalContext) {
        const validatedSymptoms = [];
        
        matches.forEach(match => {
            // Calculate clinical coherence score
            const coherenceScore = this.calculateClinicalCoherence(match, clinicalContext);
            
            // Anatomical consistency check
            const anatomicalConsistency = this.validateAnatomicalConsistency(match, matches);
            
            // Temporal consistency check
            const temporalConsistency = this.validateTemporalConsistency(match, clinicalContext);
            
            // Overall scientific confidence
            const scientificConfidence = (
                match.matchScore * 0.4 +
                coherenceScore * 0.3 +
                anatomicalConsistency * 0.15 +
                temporalConsistency * 0.15
            ) * match.clinicalSignificance;
            
            // Only accept scientifically sound matches
            if (scientificConfidence > 0.5) {
                validatedSymptoms.push({
                    id: match.hpoId || match.entity.term.replace(/\s+/g, '_'),
                    name: match.name || match.entity.term,
                    hpoId: match.hpoId,
                    matchedTerm: match.matchedTerm,
                    confidence: match.matchScore,
                    scientificConfidence,
                    severity: this.inferSeverity(match, clinicalContext),
                    temporal: this.inferTemporal(match, clinicalContext),
                    definition: match.definition,
                    synonyms: match.synonyms || [],
                    clinicalRelevance: match.clinicalSignificance,
                    anatomicalSystem: match.anatomicalSystem,
                    coherenceScore,
                    ontologySupport: this.getOntologySupport(match)
                });
            }
        });
        
        return validatedSymptoms;
    }
    
    calculateClinicalCoherence(match, clinicalContext) {
        let coherence = 0.5; // Base coherence
        
        // Anatomical system coherence
        if (match.anatomicalSystem) {
            const systemRelevance = this.getSystemRelevance(match.anatomicalSystem, clinicalContext);
            coherence += systemRelevance * 0.3;
        }
        
        // Clinical presentation coherence
        if (clinicalContext.presentationPattern) {
            const presentationMatch = this.matchPresentationPattern(match, clinicalContext.presentationPattern);
            coherence += presentationMatch * 0.2;
        }
        
        // Ontological depth bonus (more specific terms are more credible)
        const depthBonus = Math.min(match.ontologyDepth / 10, 0.2);
        coherence += depthBonus;
        
        return Math.min(coherence, 1.0);
    }
    
    validateAnatomicalConsistency(match, allMatches) {
        if (!match.anatomicalSystem) return 0.7; // Neutral if no system identified
        
        // Check if this anatomical system is consistent with other detected symptoms
        const systemMatches = allMatches.filter(m => 
            m.anatomicalSystem === match.anatomicalSystem && m.matchScore > 0.6
        );
        
        // More matches in the same system increase confidence
        const systemConfidence = Math.min(systemMatches.length / 3, 1.0);
        
        // Check for conflicting systems (should reduce confidence)
        const conflictingSystems = new Set(allMatches
            .filter(m => m.anatomicalSystem && m.anatomicalSystem !== match.anatomicalSystem)
            .map(m => m.anatomicalSystem)
        );
        
        const conflictPenalty = Math.min(conflictingSystems.size * 0.1, 0.3);
        
        return Math.max(systemConfidence - conflictPenalty, 0.1);
    }

    // ===== SUPPORTING METHODS =====
    
    buildHPOOntologyGraph() {
        const graph = new Map();
        
        if (!this.hpoData?.graphs?.[0]?.edges) return graph;
        
        // Build hierarchical relationships
        this.hpoData.graphs[0].edges.forEach(edge => {
            const subject = edge.sub.replace('http://purl.obolibrary.org/obo/', '');
            const object = edge.obj.replace('http://purl.obolibrary.org/obo/', '');
            const predicate = edge.pred;
            
            if (!graph.has(subject)) {
                graph.set(subject, { parents: [], children: [], related: [] });
            }
            if (!graph.has(object)) {
                graph.set(object, { parents: [], children: [], related: [] });
            }
            
            if (predicate === 'is_a') {
                graph.get(subject).parents.push(object);
                graph.get(object).children.push(subject);
            } else {
                graph.get(subject).related.push({ target: object, relation: predicate });
            }
        });
        
        return graph;
    }
    
    buildAnatomicalSystemMap() {
        const systemMap = new Map();
        
        const anatomicalSystems = {
            'nervous_system': ['brain', 'neural', 'nerve', 'cognitive', 'motor', 'sensory', 'neurological'],
            'cardiovascular_system': ['heart', 'cardiac', 'blood', 'vessel', 'circulation', 'vascular'],
            'respiratory_system': ['lung', 'pulmonary', 'breathing', 'respiratory', 'airway'],
            'musculoskeletal_system': ['muscle', 'bone', 'joint', 'skeletal', 'muscular'],
            'genitourinary_system': ['kidney', 'renal', 'urinary', 'bladder', 'urine'],
            'gastrointestinal_system': ['stomach', 'intestinal', 'digestive', 'gastric', 'bowel'],
            'endocrine_system': ['hormone', 'gland', 'endocrine', 'thyroid', 'diabetes'],
            'integumentary_system': ['skin', 'dermal', 'cutaneous', 'dermatological']
        };
        
        Object.entries(anatomicalSystems).forEach(([system, keywords]) => {
            keywords.forEach(keyword => {
                systemMap.set(keyword, system);
            });
        });
        
        return systemMap;
    }
    
    identifyAnatomicalSystem(name, definition) {
        const text = (name + ' ' + definition).toLowerCase();
        
        for (const [keyword, system] of this.anatomySystemMap) {
            if (text.includes(keyword)) {
                return system;
            }
        }
        
        return 'unknown_system';
    }
    
    calculateClinicalSignificance(hpoNode) {
        let significance = 0.5;
        
        const definition = hpoNode.meta?.definition?.val || '';
        const synonyms = hpoNode.meta?.synonyms || [];
        
        // Clinical keywords increase significance
        const clinicalKeywords = ['clinical', 'symptom', 'sign', 'manifestation', 'patient'];
        clinicalKeywords.forEach(keyword => {
            if (definition.toLowerCase().includes(keyword)) {
                significance += 0.1;
            }
        });
        
        // Multiple synonyms indicate well-documented concept
        significance += Math.min(synonyms.length * 0.05, 0.2);
        
        // Specific medical terminology
        const specificTerms = ['syndrome', 'disease', 'disorder', 'condition'];
        specificTerms.forEach(term => {
            if (definition.toLowerCase().includes(term)) {
                significance += 0.1;
            }
        });
        
        return Math.min(significance, 1.0);
    }
    
    calculateOntologyDepth(hpoId) {
        // Calculate depth in HPO hierarchy (more specific = deeper)
        let depth = 0;
        let currentId = hpoId;
        const visited = new Set();
        
        while (currentId && !visited.has(currentId) && depth < 20) {
            visited.add(currentId);
            const node = this.hpoOntologyGraph.get(currentId);
            if (node && node.parents.length > 0) {
                currentId = node.parents[0]; // Follow primary parent
                depth++;
            } else {
                break;
            }
        }
        
        return depth;
    }
    
    extractClinicalContext(text) {
        const context = {
            presentationPattern: null,
            temporalIndicators: [],
            severityIndicators: [],
            anatomicalReferences: []
        };
        
        // Extract presentation patterns
        const presentationPatterns = [
            /patient\s+presents?\s+with\s+([^.!?]+)/gi,
            /symptoms?\s+include\s+([^.!?]+)/gi,
            /experiencing\s+([^.!?]+)/gi
        ];
        
        presentationPatterns.forEach(pattern => {
            const match = pattern.exec(text);
            if (match) {
                context.presentationPattern = match[1].trim();
            }
        });
        
        // Extract temporal indicators
        const temporalTerms = ['acute', 'chronic', 'sudden', 'gradual', 'progressive', 'recent', 'ongoing'];
        temporalTerms.forEach(term => {
            if (text.toLowerCase().includes(term)) {
                context.temporalIndicators.push(term);
            }
        });
        
        // Extract severity indicators
        const severityTerms = ['severe', 'mild', 'moderate', 'intense', 'slight', 'debilitating'];
        severityTerms.forEach(term => {
            if (text.toLowerCase().includes(term)) {
                context.severityIndicators.push(term);
            }
        });
        
        return context;
    }
    
    normalizemedicalTerm(term) {
        return term.toLowerCase()
                   .replace(/[^\w\s]/g, '')
                   .replace(/\s+/g, ' ')
                   .trim();
    }
    
    calculateEditDistance(str1, str2) {
        const matrix = Array(str2.length + 1).fill().map(() => Array(str1.length + 1).fill(0));
        
        for (let i = 0; i <= str1.length; i++) matrix[0][i] = i;
        for (let j = 0; j <= str2.length; j++) matrix[j][0] = j;
        
        for (let j = 1; j <= str2.length; j++) {
            for (let i = 1; i <= str1.length; i++) {
                if (str1[i - 1] === str2[j - 1]) {
                    matrix[j][i] = matrix[j - 1][i - 1];
                } else {
                    matrix[j][i] = Math.min(
                        matrix[j - 1][i - 1] + 1,
                        matrix[j][i - 1] + 1,
                        matrix[j - 1][i] + 1
                    );
                }
            }
        }
        
        return matrix[str2.length][str1.length];
    }
    
    rankAndFilterMatches(matches) {
        // Remove duplicates and rank by scientific confidence
        const uniqueMatches = new Map();
        
        matches.forEach(match => {
            const key = match.hpoId || match.entity.term;
            const existing = uniqueMatches.get(key);
            
            if (!existing || match.matchScore > existing.matchScore) {
                uniqueMatches.set(key, match);
            }
        });
        
        return Array.from(uniqueMatches.values())
                    .sort((a, b) => b.matchScore - a.matchScore)
                    .slice(0, 12); // Top 12 candidates for validation
    }
    
    // Placeholder methods for additional functionality
    findSemanticHPOMatches(entity, text) { return []; }
    findAnatomicalHPOMatches(entity) { return []; }
    buildMedicalSemanticIndex() { return new Map(); }
    buildClinicalConceptNetwork() { return new Map(); }
    validateTemporalConsistency(match, context) { return 0.8; }
    getSystemRelevance(system, context) { return 0.7; }
    matchPresentationPattern(match, pattern) { return 0.6; }
    inferSeverity(match, context) { return 'moderate'; }
    inferTemporal(match, context) { return 'acute'; }
    getOntologySupport(match) { return 'HPO validated'; }
    enhanceWithMedicalKnowledge(symptoms, text) { return symptoms; }
    calculateDefinitionSimilarity(term, definition) { 
        return this.calculateSemanticSimilarity(term, definition) * 0.8; 
    }
}


// Fully Dynamic Knowledge Extractor - No Hardcoding!
class DynamicKnowledgeExtractor {
    constructor(hpoData, biomedicalKB) {
        this.hpoData = hpoData;
        this.biomedicalKB = biomedicalKB;
        this.hpoSymptomIndex = this.buildHPOSymptomIndex();
        this.hpoRelationshipGraph = this.buildHPORelationshipGraph();
        this.biomedicalEntities = this.extractAllBiomedicalEntities();
        this.crossReferences = this.buildCrossReferences();
    }

    // Extract ALL symptoms dynamically from HPO
    buildHPOSymptomIndex() {
        const symptomIndex = new Map();
        
        if (!this.hpoData?.graphs?.[0]?.nodes) {
            console.log('No HPO data available for symptom extraction');
            return symptomIndex;
        }

        this.hpoData.graphs[0].nodes.forEach(node => {
            const hpoId = node.id.replace('http://purl.obolibrary.org/obo/', '');
            const name = node.lbl || node.label;
            const definition = node.meta?.definition?.val || '';
            const synonyms = node.meta?.synonyms?.map(s => s.val) || [];
            
            // Determine if this HPO term represents a symptom/phenotype
            const isSymptom = this.classifyAsSymptom(name, definition, hpoId);
            
            if (isSymptom) {
                symptomIndex.set(hpoId, {
                    hpoId,
                    name,
                    definition,
                    synonyms,
                    searchTerms: this.generateComprehensiveSearchTerms(name, synonyms),
                    category: this.categorizeSymptom(name, definition),
                    severity: this.inferSeverityFromDefinition(definition),
                    bodySystem: this.identifyBodySystem(name, definition),
                    clinicalSignificance: this.assessClinicalSignificance(definition, synonyms.length)
                });
            }
        });

        console.log(`Extracted ${symptomIndex.size} symptoms from HPO`);
        return symptomIndex;
    }

    // Build HPO relationship graph for semantic relationships
    buildHPORelationshipGraph() {
        const graph = new Map();
        
        if (!this.hpoData?.graphs?.[0]?.edges) {
            return graph;
        }

        this.hpoData.graphs[0].edges.forEach(edge => {
            const subject = edge.sub.replace('http://purl.obolibrary.org/obo/', '');
            const object = edge.obj.replace('http://purl.obolibrary.org/obo/', '');
            const predicate = edge.pred;

            if (!graph.has(subject)) {
                graph.set(subject, { parents: [], children: [], related: [] });
            }
            if (!graph.has(object)) {
                graph.set(object, { parents: [], children: [], related: [] });
            }

            if (predicate === 'is_a') {
                graph.get(subject).parents.push(object);
                graph.get(object).children.push(subject);
            } else {
                graph.get(subject).related.push({ target: object, relation: predicate });
                graph.get(object).related.push({ target: subject, relation: predicate });
            }
        });

        console.log(`Built HPO relationship graph with ${graph.size} nodes`);
        return graph;
    }

    // Extract ALL entities from biomedical knowledge base
    extractAllBiomedicalEntities() {
        const entities = {
            conditions: new Map(),
            treatments: new Map(),
            symptoms: new Map(),
            procedures: new Map(),
            medications: new Map()
        };

        // Extract from structured KB
        if (this.biomedicalKB) {
            this.extractFromStructuredKB(entities);
        }

        // Extract from text content if available
        if (this.biomedicalKB?.textContent) {
            this.extractFromTextContent(entities, this.biomedicalKB.textContent);
        }

        console.log(`Extracted entities: ${entities.conditions.size} conditions, ${entities.treatments.size} treatments, ${entities.symptoms.size} symptoms`);
        return entities;
    }

    extractFromStructuredKB(entities) {
        // Extract conditions
        if (this.biomedicalKB.conditions) {
            Object.entries(this.biomedicalKB.conditions).forEach(([id, data]) => {
                entities.conditions.set(id, this.normalizeConditionData(id, data));
            });
        }

        // Extract treatments
        if (this.biomedicalKB.treatments) {
            Object.entries(this.biomedicalKB.treatments).forEach(([id, data]) => {
                entities.treatments.set(id, this.normalizeTreatmentData(id, data));
            });
        }

        // Extract symptoms
        if (this.biomedicalKB.symptoms) {
            Object.entries(this.biomedicalKB.symptoms).forEach(([id, data]) => {
                entities.symptoms.set(id, this.normalizeSymptomData(id, data));
            });
        }
    }

    extractFromTextContent(entities, textContent) {
        // Dynamic extraction patterns for medical entities
        const extractionPatterns = {
            conditions: [
                // Disease/disorder patterns
                /\b([A-Z][a-z]+(?:\s+[a-z]+)*)\s+(disease|disorder|syndrome|condition|cancer|carcinoma|tumor|infection|itis|osis|pathy|emia|trophy)\b/gi,
                // Specific conditions
                /\b(diabetes|hypertension|asthma|pneumonia|bronchitis|arthritis|hepatitis|migraine|epilepsy|alzheimer|parkinson|angina|infarction)\b/gi,
                // Dysfunction patterns
                /\b([A-Z][a-z]+(?:\s+[a-z]+)*)\s+(dysfunction|failure|insufficiency|deficiency)\b/gi
            ],
            treatments: [
                // Treatment patterns
                /\b([A-Z][a-z]+(?:\s+[a-z]+)*)\s+(therapy|treatment|procedure|surgery|intervention)\b/gi,
                // Medication patterns
                /\b([a-z]+(?:cillin|mycin|statin|pril|sartan|olol|pine|zole|mab))\b/gi,
                // Specific treatments
                /\b(chemotherapy|radiotherapy|dialysis|transplant|bypass|angioplasty|stent|catheter)\b/gi
            ],
            procedures: [
                /\b([A-Z][a-z]+(?:\s+[a-z]+)*)\s+(surgery|operation|procedure|biopsy|scan|test|examination)\b/gi,
                /\b(endoscopy|colonoscopy|bronchoscopy|arthroscopy|laparoscopy|cystoscopy)\b/gi
            ]
        };

        Object.entries(extractionPatterns).forEach(([entityType, patterns]) => {
            patterns.forEach(pattern => {
                this.extractEntitiesWithPattern(textContent, pattern, entities[entityType], entityType);
            });
        });
    }

    extractEntitiesWithPattern(text, pattern, entityMap, entityType) {
        let match;
        const seen = new Set();
        
        while ((match = pattern.exec(text)) !== null) {
            const fullMatch = match[0].toLowerCase();
            const entityName = match[1] ? match[1].toLowerCase() : fullMatch;
            
            if (entityName.length > 3 && !seen.has(entityName)) {
                seen.add(entityName);
                
                const entityId = entityName.replace(/\s+/g, '_').replace(/[^a-zA-Z0-9_]/g, '');
                
                if (!entityMap.has(entityId)) {
                    const context = this.extractContext(text, match.index, 200);
                    
                    entityMap.set(entityId, {
                        id: entityId,
                        name: entityName,
                        fullMatch: fullMatch,
                        context: context,
                        confidence: this.calculateExtractionConfidence(entityName, context),
                        category: this.categorizeEntity(entityName, context, entityType),
                        properties: this.inferPropertiesFromContext(context, entityType),
                        searchTerms: this.generateComprehensiveSearchTerms(entityName, [fullMatch])
                    });
                }
            }
        }
    }

    // Build cross-references between HPO and biomedical entities
    buildCrossReferences() {
        const crossRefs = {
            hpoToConditions: new Map(),
            hpoToTreatments: new Map(),
            conditionToHPO: new Map(),
            symptomToCondition: new Map(),
            conditionToTreatment: new Map()
        };

        // Map HPO symptoms to biomedical conditions using semantic similarity
        for (const [hpoId, hpoSymptom] of this.hpoSymptomIndex) {
            const relatedConditions = this.findRelatedConditions(hpoSymptom);
            const relatedTreatments = this.findRelatedTreatments(hpoSymptom);
            
            if (relatedConditions.length > 0) {
                crossRefs.hpoToConditions.set(hpoId, relatedConditions);
            }
            if (relatedTreatments.length > 0) {
                crossRefs.hpoToTreatments.set(hpoId, relatedTreatments);
            }
        }

        // Build condition-to-treatment mappings
        for (const [conditionId, condition] of this.biomedicalEntities.conditions) {
            const treatments = this.findTreatmentsForCondition(condition);
            if (treatments.length > 0) {
                crossRefs.conditionToTreatment.set(conditionId, treatments);
            }
        }

        // Build bidirectional references
        this.buildBidirectionalReferences(crossRefs);

        console.log(`Built cross-references: ${crossRefs.hpoToConditions.size} HPO-condition mappings, ${crossRefs.conditionToTreatment.size} condition-treatment mappings`);
        return crossRefs;
    }

    findRelatedConditions(hpoSymptom) {
        const relatedConditions = [];
        
        for (const [conditionId, condition] of this.biomedicalEntities.conditions) {
            const similarity = this.calculateSemanticSimilarity(hpoSymptom, condition);
            
            if (similarity > 0.3) { // Threshold for relevance
                relatedConditions.push({
                    conditionId,
                    similarity,
                    relationship: this.determineRelationshipType(hpoSymptom, condition)
                });
            }
        }

        return relatedConditions.sort((a, b) => b.similarity - a.similarity).slice(0, 10);
    }

    findRelatedTreatments(hpoSymptom) {
        const relatedTreatments = [];
        
        for (const [treatmentId, treatment] of this.biomedicalEntities.treatments) {
            const similarity = this.calculateSemanticSimilarity(hpoSymptom, treatment);
            
            if (similarity > 0.2) {
                relatedTreatments.push({
                    treatmentId,
                    similarity,
                    relationship: 'treats_symptom'
                });
            }
        }

        return relatedTreatments.sort((a, b) => b.similarity - a.similarity).slice(0, 5);
    }

    findTreatmentsForCondition(condition) {
        const treatments = [];
        
        for (const [treatmentId, treatment] of this.biomedicalEntities.treatments) {
            const relevance = this.calculateTreatmentRelevance(condition, treatment);
            
            if (relevance > 0.3) {
                treatments.push({
                    treatmentId,
                    relevance,
                    efficacy: this.estimateEfficacy(condition, treatment),
                    cost: this.estimateCost(treatment),
                    sideEffects: this.estimateSideEffects(treatment)
                });
            }
        }

        return treatments.sort((a, b) => b.relevance - a.relevance).slice(0, 8);
    }

    // Semantic similarity calculation
    calculateSemanticSimilarity(entity1, entity2) {
        const terms1 = new Set([
            entity1.name,
            ...(entity1.synonyms || []),
            ...(entity1.searchTerms || [])
        ].map(term => term.toLowerCase()));

        const terms2 = new Set([
            entity2.name,
            ...(entity2.synonyms || []),
            ...(entity2.searchTerms || [])
        ].map(term => term.toLowerCase()));

        // Jaccard similarity
        const intersection = new Set([...terms1].filter(term => terms2.has(term)));
        const union = new Set([...terms1, ...terms2]);
        
        let similarity = intersection.size / union.size;

        // Boost similarity for word overlap
        similarity += this.calculateWordOverlap(entity1.name, entity2.name) * 0.3;

        // Boost for semantic relationships
        similarity += this.calculateSemanticBoost(entity1, entity2);

        return Math.min(similarity, 1.0);
    }

    calculateWordOverlap(text1, text2) {
        const words1 = new Set(text1.toLowerCase().split(/\s+/));
        const words2 = new Set(text2.toLowerCase().split(/\s+/));
        
        const intersection = new Set([...words1].filter(word => words2.has(word)));
        const union = new Set([...words1, ...words2]);
        
        return intersection.size / union.size;
    }

    calculateSemanticBoost(entity1, entity2) {
        let boost = 0;
        
        // Body system matching
        if (entity1.bodySystem && entity2.category && 
            entity1.bodySystem === entity2.category) {
            boost += 0.2;
        }

        // Context similarity
        if (entity1.context && entity2.context) {
            boost += this.calculateWordOverlap(entity1.context, entity2.context) * 0.1;
        }

        return boost;
    }

    // Utility methods for classification and inference
    classifyAsSymptom(name, definition, hpoId) {
        const lowerName = name.toLowerCase();
        const lowerDef = definition.toLowerCase();
        
        // Exclude anatomical structures and developmental terms
        const excludePatterns = [
            /abnormality of.*morphology/,
            /abnormal.*shape/,
            /absent/,
            /agenesis/,
            /aplasia/,
            /malformation/,
            /increased.*size/,
            /decreased.*size/
        ];

        if (excludePatterns.some(pattern => pattern.test(lowerName + ' ' + lowerDef))) {
            return false;
        }

        // Include symptom patterns
        const includePatterns = [
            /pain/,
            /ache/,
            /bleeding/,
            /discharge/,
            /fever/,
            /nausea/,
            /fatigue/,
            /weakness/,
            /difficulty/,
            /loss/,
            /sensation/,
            /movement/,
            /function/
        ];

        return includePatterns.some(pattern => pattern.test(lowerName + ' ' + lowerDef));
    }

    categorizeSymptom(name, definition) {
        const text = (name + ' ' + definition).toLowerCase();
        
        const categories = {
            'neurological': /brain|nerve|neural|cognitive|memory|seizure|headache|migraine/,
            'cardiovascular': /heart|cardiac|blood|vessel|circulation|pressure|pulse/,
            'respiratory': /lung|breath|respiratory|cough|dyspnea|pneumonia/,
            'gastrointestinal': /stomach|intestinal|digestive|nausea|vomiting|diarrhea/,
            'genitourinary': /kidney|renal|urinary|bladder|urine|genital/,
            'musculoskeletal': /muscle|bone|joint|skeletal|arthritis|myalgia/,
            'dermatological': /skin|dermal|rash|lesion|pigmentation/,
            'ophthalmological': /eye|ocular|visual|corneal|retinal|vision/,
            'endocrine': /hormone|gland|diabetes|thyroid|metabolic/,
            'hematological': /blood|hematological|anemia|bleeding|coagulation/
        };

        for (const [category, pattern] of Object.entries(categories)) {
            if (pattern.test(text)) return category;
        }

        return 'general';
    }

    identifyBodySystem(name, definition) {
        return this.categorizeSymptom(name, definition);
    }

    assessClinicalSignificance(definition, synonymCount) {
        let significance = 0.5;
        
        if (definition.length > 100) significance += 0.2;
        if (synonymCount > 2) significance += 0.1;
        if (/severe|critical|life-threatening/.test(definition)) significance += 0.3;
        if (/common|frequent/.test(definition)) significance += 0.1;
        
        return Math.min(significance, 1.0);
    }

    generateComprehensiveSearchTerms(name, synonyms) {
        const terms = new Set([name.toLowerCase()]);
        
        // Add synonyms
        synonyms.forEach(synonym => terms.add(synonym.toLowerCase()));
        
        // Add word variants
        const words = name.toLowerCase().split(/\s+/);
        words.forEach(word => {
            if (word.length > 3) {
                terms.add(word);
                // Add medical variants
                this.generateMedicalVariants(word).forEach(variant => terms.add(variant));
            }
        });

        return Array.from(terms);
    }

    generateMedicalVariants(word) {
        const variants = [];
        
        // Common medical suffixes and their variants
        const suffixMap = {
            'algia': ['pain', 'ache'],
            'uria': ['in urine'],
            'pnea': ['breathing', 'breath'],
            'itis': ['inflammation'],
            'osis': ['condition'],
            'pathy': ['disease'],
            'emia': ['in blood']
        };

        Object.entries(suffixMap).forEach(([suffix, meanings]) => {
            if (word.endsWith(suffix)) {
                const root = word.slice(0, -suffix.length);
                meanings.forEach(meaning => {
                    variants.push(`${root} ${meaning}`);
                });
            }
        });

        return variants;
    }

    // Property inference methods
    inferPropertiesFromContext(context, entityType) {
        const properties = {};
        
        if (entityType === 'conditions') {
            properties.severity = this.inferSeverityFromDefinition(context);
            properties.prognosis = this.inferPrognosisFromContext(context);
            properties.chronicityRisk = this.inferChronicityFromContext(context);
        } else if (entityType === 'treatments') {
            properties.efficacy = this.inferEfficacyFromContext(context);
            properties.cost = this.inferCostFromContext(context);
            properties.sideEffects = this.inferSideEffectsFromContext(context);
        }

        return properties;
    }

    inferSeverityFromDefinition(text) {
        const lowerText = text.toLowerCase();
        
        if (/severe|critical|life-threatening|fatal|emergency/.test(lowerText)) return 'severe';
        if (/moderate|significant|notable/.test(lowerText)) return 'moderate';
        if (/mild|minor|slight|benign/.test(lowerText)) return 'mild';
        
        return 'moderate';
    }

    inferPrognosisFromContext(context) {
        const lowerContext = context.toLowerCase();
        
        if (/excellent|cure|full recovery/.test(lowerContext)) {
            return 'Excellent prognosis with appropriate treatment';
        }
        if (/good|favorable|positive/.test(lowerContext)) {
            return 'Good prognosis with proper management';
        }
        if (/poor|guarded|variable/.test(lowerContext)) {
            return 'Variable prognosis depending on treatment response';
        }
        
        return 'Prognosis depends on timely intervention and individual factors';
    }

    calculateExtractionConfidence(entityName, context) {
        let confidence = 0.5;
        
        if (entityName.length > 6) confidence += 0.1;
        if (context.includes('treatment') || context.includes('therapy')) confidence += 0.1;
        if (context.includes('patient') || context.includes('clinical')) confidence += 0.1;
        if (/\b(disease|disorder|syndrome|condition)\b/.test(context)) confidence += 0.2;
        
        return Math.min(confidence, 1.0);
    }

    // Main interface methods
    getSymptomsByText(text) {
        const matchedSymptoms = [];
        const lowerText = text.toLowerCase();
        
        for (const [hpoId, symptom] of this.hpoSymptomIndex) {
            const matchScore = this.calculateTextMatch(lowerText, symptom);
            
            if (matchScore > 0.3) {
                matchedSymptoms.push({
                    ...symptom,
                    matchScore,
                    matchedTerms: this.getMatchedTerms(lowerText, symptom)
                });
            }
        }
        
        return matchedSymptoms.sort((a, b) => b.matchScore - a.matchScore);
    }

    getConditionsForSymptoms(symptoms) {
        const conditionScores = new Map();
        
        symptoms.forEach(symptom => {
            const relatedConditions = this.crossReferences.hpoToConditions.get(symptom.hpoId) || [];
            
            relatedConditions.forEach(conditionRef => {
                const conditionData = this.biomedicalEntities.conditions.get(conditionRef.conditionId);
                
                if (conditionData) {
                    const score = conditionRef.similarity * symptom.matchScore * symptom.clinicalSignificance;
                    
                    if (!conditionScores.has(conditionRef.conditionId)) {
                        conditionScores.set(conditionRef.conditionId, {
                            condition: conditionData,
                            score: 0,
                            evidence: []
                        });
                    }
                    
                    const conditionInfo = conditionScores.get(conditionRef.conditionId);
                    conditionInfo.score += score;
                    conditionInfo.evidence.push({
                        symptom: symptom.name,
                        similarity: conditionRef.similarity,
                        relationship: conditionRef.relationship
                    });
                }
            });
        });
        
        return Array.from(conditionScores.entries())
            .map(([conditionId, info]) => ({
                conditionId,
                ...info.condition,
                probability: Math.min(info.score, 1.0),
                evidence: info.evidence,
                treatments: this.getTreatmentsForCondition(conditionId)
            }))
            .sort((a, b) => b.probability - a.probability);
    }

    getTreatmentsForCondition(conditionId) {
        const treatments = this.crossReferences.conditionToTreatment.get(conditionId) || [];
        
        return treatments.map(treatmentRef => {
            const treatmentData = this.biomedicalEntities.treatments.get(treatmentRef.treatmentId);
            return {
                ...treatmentData,
                relevance: treatmentRef.relevance,
                efficacy: treatmentRef.efficacy,
                cost: treatmentRef.cost,
                sideEffects: treatmentRef.sideEffects
            };
        });
    }

    calculateTextMatch(text, symptom) {
        let maxScore = 0;
        
        symptom.searchTerms.forEach(term => {
            if (text.includes(term)) {
                const score = term.length / text.length * symptom.clinicalSignificance;
                maxScore = Math.max(maxScore, score);
            }
        });
        
        return maxScore;
    }

    getMatchedTerms(text, symptom) {
        return symptom.searchTerms.filter(term => text.includes(term));
    }

// Missing methods for DynamicKnowledgeExtractor class
// Add these methods to the DynamicKnowledgeExtractor class

// Data normalization methods
normalizeConditionData(id, data) {
    const name = data.name || id;
    const properties = data.properties || {};
    
    return {
        id,
        name: name.replace(/_/g, ' '),
        description: properties.description || data.description || '',
        context: properties.context || data.context || '',
        confidence: properties.confidence || data.confidence || 0.7,
        category: this.categorizeEntity(name, properties.description || '', 'conditions'),
        properties: {
            severity: properties.severity || this.inferSeverityFromDefinition(properties.description || ''),
            prognosis: properties.prognosis || this.inferPrognosisFromContext(properties.description || ''),
            chronicityRisk: properties.chronicityRisk || this.inferChronicityFromContext(properties.description || ''),
            prevalence: properties.prevalence || 0.1
        },
        searchTerms: this.generateComprehensiveSearchTerms(name, []),
        source: 'biomedical_kb'
    };
}

normalizeTreatmentData(id, data) {
    const name = data.name || id;
    const properties = data.properties || {};
    
    return {
        id,
        name: name.replace(/_/g, ' '),
        description: properties.description || data.description || '',
        context: properties.context || data.context || '',
        confidence: properties.confidence || data.confidence || 0.7,
        category: this.categorizeEntity(name, properties.description || '', 'treatments'),
        properties: {
            efficacy: this.parseNumericValue(properties.efficacy, 0.7),
            cost: this.parseNumericValue(properties.cost, 1000),
            sideEffects: this.parseNumericValue(properties.side_effects || properties.sideEffects, 0.2),
            contraindications: this.parseArray(properties.contraindications)
        },
        searchTerms: this.generateComprehensiveSearchTerms(name, []),
        source: 'biomedical_kb'
    };
}

normalizeSymptomData(id, data) {
    const name = data.name || id;
    const properties = data.properties || {};
    
    return {
        id,
        name: name.replace(/_/g, ' '),
        description: properties.description || data.description || '',
        context: properties.context || data.context || '',
        confidence: properties.confidence || data.confidence || 0.7,
        category: this.categorizeEntity(name, properties.description || '', 'symptoms'),
        properties: {
            severity_range: properties.severity_range || [1, 10],
            associated_conditions: this.parseArray(properties.associated_conditions)
        },
        searchTerms: this.generateComprehensiveSearchTerms(name, []),
        source: 'biomedical_kb'
    };
}

// Entity categorization method
categorizeEntity(name, description, entityType) {
    const text = (name + ' ' + description).toLowerCase();
    
    if (entityType === 'conditions') {
        return this.categorizeCondition(text);
    } else if (entityType === 'treatments') {
        return this.categorizeTreatment(text);
    } else if (entityType === 'symptoms') {
        return this.categorizeSymptom(name, description);
    }
    
    return 'general';
}

categorizeCondition(text) {
    const categories = {
        'cardiovascular': /heart|cardiac|blood|vessel|circulation|pressure|pulse|angina|infarction|arrhythmia/,
        'respiratory': /lung|breath|respiratory|cough|dyspnea|pneumonia|asthma|bronchitis/,
        'neurological': /brain|nerve|neural|cognitive|memory|seizure|headache|migraine|stroke|epilepsy/,
        'gastrointestinal': /stomach|intestinal|digestive|nausea|vomiting|diarrhea|gastritis|colitis/,
        'genitourinary': /kidney|renal|urinary|bladder|urine|genital|nephritis|cystitis/,
        'musculoskeletal': /muscle|bone|joint|skeletal|arthritis|myalgia|fracture|osteo/,
        'dermatological': /skin|dermal|rash|lesion|pigmentation|dermatitis|eczema/,
        'ophthalmological': /eye|ocular|visual|corneal|retinal|vision|glaucoma|cataract/,
        'endocrine': /hormone|gland|diabetes|thyroid|metabolic|insulin|glucose/,
        'hematological': /blood|hematological|anemia|bleeding|coagulation|leukemia/,
        'infectious': /infection|bacterial|viral|fungal|sepsis|pneumonia|meningitis/,
        'oncological': /cancer|tumor|carcinoma|sarcoma|lymphoma|metastasis|malignant/,
        'psychiatric': /depression|anxiety|bipolar|schizophrenia|psychosis|mood/,
        'immunological': /immune|allergy|autoimmune|lupus|rheumatoid|immunodeficiency/
    };

    for (const [category, pattern] of Object.entries(categories)) {
        if (pattern.test(text)) return category;
    }

    return 'general';
}

categorizeTreatment(text) {
    const categories = {
        'surgical': /surgery|operation|transplant|resection|bypass|angioplasty|laparoscopy/,
        'pharmacological': /medication|drug|antibiotic|analgesic|steroid|insulin|chemotherapy/,
        'therapeutic': /therapy|rehabilitation|counseling|psychotherapy|physical|occupational/,
        'procedural': /procedure|catheter|endoscopy|biopsy|dialysis|transfusion/,
        'supportive': /supportive|palliative|comfort|symptomatic|monitoring/,
        'preventive': /prevention|prophylaxis|vaccination|screening|lifestyle/,
        'diagnostic': /diagnosis|test|scan|imaging|laboratory|pathology/
    };

    for (const [category, pattern] of Object.entries(categories)) {
        if (pattern.test(text)) return category;
    }

    return 'general';
}

// Utility methods for parsing data
parseNumericValue(value, defaultValue) {
    if (typeof value === 'number') return value;
    if (typeof value === 'string') {
        const parsed = parseFloat(value);
        return isNaN(parsed) ? defaultValue : parsed;
    }
    return defaultValue;
}

parseArray(value) {
    if (Array.isArray(value)) return value;
    if (typeof value === 'string') {
        return value.split(',').map(s => s.trim()).filter(s => s.length > 0);
    }
    return [];
}

// Context extraction utility
extractContext(text, position, length) {
    const start = Math.max(0, position - length / 2);
    const end = Math.min(text.length, position + length / 2);
    return text.substring(start, end).trim();
}

// Treatment relevance calculation
calculateTreatmentRelevance(condition, treatment) {
    let relevance = 0;
    
    // Check name similarity
    relevance += this.calculateWordOverlap(condition.name, treatment.name) * 0.4;
    
    // Check description/context similarity
    const conditionText = condition.description || condition.context || '';
    const treatmentText = treatment.description || treatment.context || '';
    relevance += this.calculateWordOverlap(conditionText, treatmentText) * 0.3;
    
    // Category matching bonus
    if (condition.category === treatment.category) {
        relevance += 0.2;
    }
    
    // Medical domain matching
    if (this.sharesMedicalDomain(condition, treatment)) {
        relevance += 0.3;
    }
    
    return Math.min(relevance, 1.0);
}

sharesMedicalDomain(condition, treatment) {
    const conditionDomain = this.extractMedicalDomain(condition.name + ' ' + condition.description);
    const treatmentDomain = this.extractMedicalDomain(treatment.name + ' ' + treatment.description);
    
    return conditionDomain === treatmentDomain && conditionDomain !== 'general';
}

extractMedicalDomain(text) {
    const lowerText = text.toLowerCase();
    
    const domains = {
        'cardiology': /heart|cardiac|cardiovascular|coronary/,
        'ophthalmology': /eye|ocular|visual|corneal|retinal/,
        'neurology': /brain|neural|neurological|nerve/,
        'urology': /kidney|renal|urinary|bladder/,
        'gastroenterology': /stomach|intestinal|digestive|gastric/,
        'orthopedics': /bone|joint|muscle|skeletal/,
        'dermatology': /skin|dermal|cutaneous/,
        'pulmonology': /lung|respiratory|pulmonary/,
        'endocrinology': /hormone|endocrine|thyroid|diabetes/,
        'oncology': /cancer|tumor|oncology|malignant/
    };
    
    for (const [domain, pattern] of Object.entries(domains)) {
        if (pattern.test(lowerText)) return domain;
    }
    
    return 'general';
}

// Estimate efficacy, cost, and side effects for treatments
estimateEfficacy(condition, treatment) {
    // Base efficacy from treatment properties
    let efficacy = treatment.properties?.efficacy || 0.7;
    
    // Adjust based on condition severity
    const conditionSeverity = condition.properties?.severity || 'moderate';
    if (conditionSeverity === 'severe') efficacy *= 0.9;
    else if (conditionSeverity === 'mild') efficacy *= 1.1;
    
    // Adjust based on treatment category
    const treatmentCategory = treatment.category;
    if (treatmentCategory === 'surgical') efficacy *= 1.1;
    else if (treatmentCategory === 'supportive') efficacy *= 0.8;
    
    return Math.max(0.3, Math.min(1.0, efficacy));
}

estimateCost(treatment) {
    // Base cost from treatment properties
    let cost = treatment.properties?.cost || 1000;
    
    // Adjust based on treatment category
    const category = treatment.category;
    const categoryMultipliers = {
        'surgical': 15,
        'procedural': 5,
        'pharmacological': 1,
        'therapeutic': 2,
        'supportive': 0.5,
        'diagnostic': 1.5
    };
    
    cost *= (categoryMultipliers[category] || 1);
    
    // Adjust based on treatment name keywords
    const name = treatment.name.toLowerCase();
    if (/transplant|surgery/.test(name)) cost *= 3;
    if (/therapy|rehabilitation/.test(name)) cost *= 1.5;
    if (/medication|drug/.test(name)) cost *= 0.8;
    
    return Math.max(50, Math.round(cost));
}

estimateSideEffects(treatment) {
    // Base side effects from treatment properties
    let sideEffects = treatment.properties?.sideEffects || 0.2;
    
    // Adjust based on treatment category
    const category = treatment.category;
    const categoryAdjustments = {
        'surgical': 0.1,      // Higher side effects
        'pharmacological': 0.05,
        'procedural': 0.08,
        'therapeutic': -0.05,  // Lower side effects
        'supportive': -0.1
    };
    
    sideEffects += (categoryAdjustments[category] || 0);
    
    // Adjust based on treatment complexity
    const name = treatment.name.toLowerCase();
    if (/chemotherapy|radiation/.test(name)) sideEffects += 0.2;
    if (/surgery|transplant/.test(name)) sideEffects += 0.1;
    if (/supportive|care/.test(name)) sideEffects -= 0.1;
    
    return Math.max(0.02, Math.min(0.8, sideEffects));
}

// Build bidirectional references
buildBidirectionalReferences(crossRefs) {
    // Build condition-to-HPO reverse mapping
    for (const [hpoId, conditions] of crossRefs.hpoToConditions) {
        conditions.forEach(conditionRef => {
            if (!crossRefs.conditionToHPO.has(conditionRef.conditionId)) {
                crossRefs.conditionToHPO.set(conditionRef.conditionId, []);
            }
            crossRefs.conditionToHPO.get(conditionRef.conditionId).push({
                hpoId,
                similarity: conditionRef.similarity,
                relationship: conditionRef.relationship
            });
        });
    }
    
    // Build symptom-to-condition mapping from biomedical KB
    for (const [symptomId, symptom] of this.biomedicalEntities.symptoms) {
        if (symptom.properties?.associated_conditions) {
            crossRefs.symptomToCondition.set(symptomId, 
                symptom.properties.associated_conditions.map(conditionId => ({
                    conditionId,
                    relationship: 'associated_with',
                    strength: 0.7
                }))
            );
        }
    }
}

// Inference methods for context-based analysis
inferChronicityFromContext(context) {
    const lowerContext = context.toLowerCase();
    
    if (/chronic|long.?term|progressive|degenerative|permanent/.test(lowerContext)) return 0.8;
    if (/acute|short.?term|temporary|transient/.test(lowerContext)) return 0.2;
    if (/recurrent|episodic|intermittent/.test(lowerContext)) return 0.5;
    if (/congenital|inherited|genetic/.test(lowerContext)) return 0.9;
    
    return 0.4;
}

inferEfficacyFromContext(context) {
    const lowerContext = context.toLowerCase();
    
    if (/highly?\s+effective|excellent|cure|outstanding/.test(lowerContext)) return 0.9;
    if (/effective|successful|good|beneficial/.test(lowerContext)) return 0.75;
    if (/moderately?\s+effective|fair|adequate/.test(lowerContext)) return 0.6;
    if (/limited|poor|minimal/.test(lowerContext)) return 0.4;
    
    return 0.7;
}

inferCostFromContext(context) {
    const lowerContext = context.toLowerCase();
    
    if (/expensive|costly|high.?cost|premium/.test(lowerContext)) return 5000;
    if (/affordable|low.?cost|inexpensive|cheap/.test(lowerContext)) return 200;
    if (/surgery|operation|transplant/.test(lowerContext)) return 25000;
    if (/medication|drug|therapy/.test(lowerContext)) return 1000;
    
    return 1500;
}

inferSideEffectsFromContext(context) {
    const lowerContext = context.toLowerCase();
    
    if (/serious|severe|significant.*side.*effects/.test(lowerContext)) return 0.4;
    if (/mild|minor|few.*side.*effects/.test(lowerContext)) return 0.1;
    if (/side.*effects|adverse|complications/.test(lowerContext)) return 0.25;
    if (/well.?tolerated|safe/.test(lowerContext)) return 0.05;
    
    return 0.2;
}

// Determine relationship types between entities
determineRelationshipType(hpoSymptom, condition) {
    const symptomName = hpoSymptom.name.toLowerCase();
    const conditionName = condition.name.toLowerCase();
    
    // Direct name inclusion
    if (conditionName.includes(symptomName) || symptomName.includes(conditionName)) {
        return 'direct_association';
    }
    
    // Body system matching
    if (hpoSymptom.bodySystem === condition.category) {
        return 'system_association';
    }
    
    // Semantic similarity
    return 'semantic_association';
}

}

// Complete Universal Medical Mapper - All Methods Properly Defined
class UniversalMedicalMapper {
    constructor(biomedicalKB, hpoData) {
        this.biomedicalKB = biomedicalKB;
        this.hpoData = hpoData;
        
        // Build comprehensive knowledge structures from actual data
        this.hpoIndex = this.buildCompleteHPOIndex();
        this.medicalOntology = this.buildMedicalOntologyGraph();
        
        console.log('Universal mapper initialized');
        console.log(`HPO concepts indexed: ${this.hpoIndex.size}`);
        console.log(`Medical relationships: ${this.medicalOntology.size}`);
    }

    // ===== CORE UNIVERSAL MAPPING METHOD =====
    
    mapSymptomsToConditions(detectedSymptoms) {
        console.log('=== Universal Medical Knowledge Mapping ===');
        console.log('Input symptoms:', detectedSymptoms.length);
        
        if (detectedSymptoms.length === 0) {
            return [];
        }
        
        try {
            // Stage 1: HPO Ontology Navigation
            const ontologyMappings = this.navigateHPOOntology(detectedSymptoms);
            console.log('Ontology mappings found:', ontologyMappings.length);
            
            // Stage 2: Medical Knowledge Extraction
            const knowledgeMappings = this.extractMedicalKnowledge(detectedSymptoms);
            console.log('Knowledge mappings found:', knowledgeMappings.length);
            
            // Stage 3: Clinical Pattern Recognition
            const patternMappings = this.recognizeClinicalPatterns(detectedSymptoms);
            console.log('Pattern mappings found:', patternMappings.length);
            
            // Stage 4: Biomedical Knowledge Integration
            const biomedicalMappings = this.integrateBiomedicalKnowledge(detectedSymptoms);
            console.log('Biomedical mappings found:', biomedicalMappings.length);
            
            // Stage 5: Medical Reasoning Synthesis
            const synthesizedConditions = this.synthesizeMedicalReasoning(
                ontologyMappings,
                knowledgeMappings,
                patternMappings,
                biomedicalMappings,
                detectedSymptoms
            );
            
            console.log('Final synthesized conditions:', synthesizedConditions.length);
            synthesizedConditions.forEach(c => 
                console.log(`- ${c.name}: ${(c.probability * 100).toFixed(1)}% (${c.evidence.length} evidence points)`)
            );
            
            return synthesizedConditions;
            
        } catch (error) {
            console.error('Error in mapping process:', error);
            // Return fallback conditions
            return this.generateFallbackConditions(detectedSymptoms);
        }
    }

    // ===== STAGE 1: HPO ONTOLOGY NAVIGATION =====
    
    navigateHPOOntology(symptoms) {
        const ontologyMappings = [];
        
        symptoms.forEach(symptom => {
            if (symptom.hpoId) {
                console.log(`Navigating HPO ontology for ${symptom.hpoId}: ${symptom.name}`);
                
                // Get comprehensive HPO information
                const hpoInfo = this.getHPOInformation(symptom.hpoId);
                console.log(`HPO info for ${symptom.hpoId}:`, hpoInfo);
                
                if (hpoInfo) {
                    // Extract conditions from HPO definition and relationships
                    const definitionConditions = this.extractConditionsFromDefinition(hpoInfo);
                    const relationshipConditions = this.extractConditionsFromRelationships(symptom.hpoId);
                    const hierarchyConditions = this.extractConditionsFromHierarchy(symptom.hpoId);
                    
                    console.log(`Definition conditions: ${definitionConditions.length}`);
                    console.log(`Relationship conditions: ${relationshipConditions.length}`);
                    console.log(`Hierarchy conditions: ${hierarchyConditions.length}`);
                    
                    // Combine all HPO-derived conditions
                    const allHPOConditions = [
                        ...definitionConditions,
                        ...relationshipConditions,
                        ...hierarchyConditions
                    ];
                    
                    allHPOConditions.forEach(condition => {
                        ontologyMappings.push({
                            ...condition,
                            sourceSymptom: symptom,
                            mappingType: 'hpo_ontology',
                            confidence: condition.confidence * symptom.confidence
                        });
                    });
                }
            }
        });
        
        return ontologyMappings;
    }
    
    getHPOInformation(hpoId) {
        const hpoInfo = this.hpoIndex.get(hpoId);
        if (!hpoInfo) {
            console.log(`No HPO information found for ${hpoId}`);
            return null;
        }
        
        return {
            id: hpoInfo.id,
            name: hpoInfo.name,
            definition: hpoInfo.definition,
            synonyms: hpoInfo.synonyms,
            parents: this.getHPOParents(hpoId),
            children: this.getHPOChildren(hpoId),
            relationships: this.getHPORelationships(hpoId),
            anatomicalSystem: this.inferAnatomicalSystem(hpoInfo),
            clinicalContext: this.extractClinicalContext(hpoInfo)
        };
    }
    
    extractConditionsFromDefinition(hpoInfo) {
        if (!hpoInfo || !hpoInfo.definition) return [];
        
        const definition = hpoInfo.definition.toLowerCase();
        const extractedConditions = [];
        
        // Enhanced condition extraction patterns
        const conditionPatterns = [
            // Direct condition mentions
            /\b(stroke|infarction|hemorrhage|thrombosis|embolism)\b/gi,
            /\b(neuropathy|myopathy|dystrophy|sclerosis|epilepsy)\b/gi,
            /\b(arthritis|osteoporosis|fracture|dislocation)\b/gi,
            /\b(pneumonia|asthma|emphysema|bronchitis)\b/gi,
            /\b(nephritis|cystitis|stones|calculi)\b/gi,
            /\b(gastritis|colitis|ulcer|obstruction)\b/gi,
            /\b(cancer|tumor|carcinoma|sarcoma|lymphoma)\b/gi,
            
            // Pathophysiological processes
            /(?:occlusion|rupture|damage|injury|dysfunction)\s+(?:of|to)\s+([^,.;]+)/gi,
            /(?:inflammation|infection|obstruction)\s+(?:of|in)\s+([^,.;]+)/gi
        ];
        
        conditionPatterns.forEach(pattern => {
            let match;
            while ((match = pattern.exec(definition)) !== null) {
                const conditionText = match[1] || match[0];
                if (conditionText.length > 3 && conditionText.length < 50) {
                    const condition = this.createConditionFromText(conditionText.trim(), hpoInfo.anatomicalSystem);
                    condition.confidence = 0.8;
                    condition.evidence = 'hpo_definition';
                    extractedConditions.push(condition);
                }
            }
        });
        
        return extractedConditions;
    }
    
    extractConditionsFromRelationships(hpoId) {
        const relationships = this.getHPORelationships(hpoId);
        const conditions = [];
        
        relationships.forEach(rel => {
            const relatedHPO = this.hpoIndex.get(rel.target);
            if (relatedHPO) {
                const relatedConditions = this.inferConditionsFromHPOTerm(relatedHPO);
                relatedConditions.forEach(condition => {
                    condition.confidence *= 0.7;
                    condition.evidence = `hpo_relationship_${rel.relation}`;
                    conditions.push(condition);
                });
            }
        });
        
        return conditions;
    }
    
    extractConditionsFromHierarchy(hpoId) {
        const parents = this.getHPOParents(hpoId);
        const children = this.getHPOChildren(hpoId);
        const conditions = [];
        
        // Process parent terms
        parents.forEach(parentId => {
            const parentHPO = this.hpoIndex.get(parentId);
            if (parentHPO) {
                const parentConditions = this.inferConditionsFromHPOTerm(parentHPO);
                parentConditions.forEach(condition => {
                    condition.confidence *= 0.6;
                    condition.evidence = 'hpo_parent_hierarchy';
                    conditions.push(condition);
                });
            }
        });
        
        // Process child terms
        children.forEach(childId => {
            const childHPO = this.hpoIndex.get(childId);
            if (childHPO) {
                const childConditions = this.inferConditionsFromHPOTerm(childHPO);
                childConditions.forEach(condition => {
                    condition.confidence *= 0.8;
                    condition.evidence = 'hpo_child_hierarchy';
                    conditions.push(condition);
                });
            }
        });
        
        return conditions;
    }

    // ===== STAGE 2: MEDICAL KNOWLEDGE EXTRACTION =====
    
    extractMedicalKnowledge(symptoms) {
        const knowledgeMappings = [];
        
        symptoms.forEach(symptom => {
            // Extract from medical terminology
            const terminologyConditions = this.extractFromMedicalTerminology(symptom);
            knowledgeMappings.push(...terminologyConditions);
            
            // Extract from anatomical correlations
            const anatomicalConditions = this.extractAnatomicalCorrelations(symptom);
            knowledgeMappings.push(...anatomicalConditions);
            
            // Extract from pathophysiological reasoning
            const pathophysiologyConditions = this.extractPathophysiologyMappings(symptom);
            knowledgeMappings.push(...pathophysiologyConditions);
        });
        
        return knowledgeMappings;
    }
    
    extractFromMedicalTerminology(symptom) {
        const conditions = [];
        const name = symptom.name.toLowerCase();
        
        // Comprehensive medical terminology mapping
        const terminologyMap = {
            'stroke': ['ischemic_stroke', 'hemorrhagic_stroke', 'cerebral_infarction', 'transient_ischemic_attack'],
            'weakness': ['stroke', 'myasthenia_gravis', 'muscular_dystrophy', 'peripheral_neuropathy'],
            'numbness': ['stroke', 'diabetic_neuropathy', 'multiple_sclerosis', 'peripheral_neuropathy'],
            'asthenia': ['chronic_fatigue_syndrome', 'fibromyalgia', 'thyroid_disorder', 'anemia'],
            'hypoesthesia': ['stroke', 'peripheral_neuropathy', 'spinal_cord_injury', 'multiple_sclerosis'],
            'abdominal_pain': ['appendicitis', 'kidney_stones', 'gallstones', 'bowel_obstruction'],
            'chest_pain': ['myocardial_infarction', 'angina', 'pulmonary_embolism', 'pneumonia'],
            'headache': ['migraine', 'tension_headache', 'cluster_headache', 'increased_intracranial_pressure']
        };
        
        Object.entries(terminologyMap).forEach(([symptomTerm, conditionList]) => {
            if (name.includes(symptomTerm) || symptomTerm.includes(name)) {
                conditionList.forEach(conditionName => {
                    conditions.push({
                        id: conditionName.replace(/\s+/g, '_'),
                        name: conditionName.replace(/_/g, ' '),
                        confidence: 0.7,
                        evidence: 'medical_terminology',
                        anatomicalSystem: this.getAnatomicalSystemForCondition(conditionName)
                    });
                });
            }
        });
        
        return conditions;
    }
    
    extractAnatomicalCorrelations(symptom) {
        const anatomicalSystem = this.inferAnatomicalSystem(symptom);
        if (!anatomicalSystem || anatomicalSystem === 'general') return [];
        
        const systemConditions = {
            'cardiovascular': ['myocardial_infarction', 'heart_failure', 'arrhythmia', 'hypertension'],
            'respiratory': ['pneumonia', 'asthma', 'chronic_obstructive_pulmonary_disease', 'pulmonary_embolism'],
            'neurological': ['stroke', 'multiple_sclerosis', 'epilepsy', 'migraine', 'peripheral_neuropathy'],
            'gastrointestinal': ['gastroenteritis', 'peptic_ulcer', 'inflammatory_bowel_disease', 'appendicitis'],
            'genitourinary': ['kidney_stones', 'urinary_tract_infection', 'chronic_kidney_disease', 'bladder_cancer'],
            'musculoskeletal': ['arthritis', 'osteoporosis', 'fibromyalgia', 'muscle_strain'],
            'endocrine': ['diabetes', 'thyroid_disorder', 'adrenal_insufficiency', 'hormonal_imbalance']
        };
        
        const conditions = systemConditions[anatomicalSystem] || [];
        return conditions.map(condition => ({
            id: condition.replace(/\s+/g, '_'),
            name: condition.replace(/_/g, ' '),
            confidence: 0.6,
            evidence: 'anatomical_correlation',
            anatomicalSystem: anatomicalSystem
        }));
    }
    
    extractPathophysiologyMappings(symptom) {
        const conditions = [];
        const symptomName = symptom.name.toLowerCase();
        
        // Pathophysiology-based condition mapping
        const pathophysiologyMap = {
            'stroke': {
                pathways: ['vascular_occlusion', 'cerebral_hemorrhage', 'thromboembolism'],
                conditions: ['ischemic_stroke', 'hemorrhagic_stroke', 'cerebral_infarction', 'transient_ischemic_attack']
            },
            'weakness': {
                pathways: ['motor_pathway_dysfunction', 'neuromuscular_junction', 'muscle_disease'],
                conditions: ['stroke', 'myasthenia_gravis', 'muscular_dystrophy', 'peripheral_neuropathy']
            },
            'asthenia': {
                pathways: ['systemic_weakness', 'metabolic_dysfunction', 'chronic_disease'],
                conditions: ['chronic_fatigue_syndrome', 'fibromyalgia', 'thyroid_disorder', 'depression']
            },
            'numbness': {
                pathways: ['sensory_pathway_dysfunction', 'peripheral_nerve_damage', 'central_nervous_system'],
                conditions: ['stroke', 'diabetic_neuropathy', 'multiple_sclerosis', 'spinal_cord_injury']
            },
            'hypoesthesia': {
                pathways: ['sensory_loss', 'nerve_dysfunction', 'central_processing'],
                conditions: ['stroke', 'peripheral_neuropathy', 'spinal_cord_injury', 'multiple_sclerosis']
            }
        };
        
        // Find matching pathophysiology
        Object.entries(pathophysiologyMap).forEach(([symptomTerm, pathophysiology]) => {
            if (symptomName.includes(symptomTerm) || symptomTerm.includes(symptomName)) {
                pathophysiology.conditions.forEach(conditionName => {
                    conditions.push({
                        id: conditionName.replace(/\s+/g, '_'),
                        name: conditionName.replace(/_/g, ' '),
                        confidence: 0.75,
                        evidence: 'pathophysiology_mapping',
                        pathophysiology: pathophysiology.pathways
                    });
                });
            }
        });
        
        return conditions;
    }

    // ===== STAGE 3: CLINICAL PATTERN RECOGNITION =====
    
    recognizeClinicalPatterns(symptoms) {
        const patterns = [];
        
        const clinicalSyndromes = this.identifyClinicalSyndromes(symptoms);
        patterns.push(...clinicalSyndromes);
        
        return patterns;
    }
    
    identifyClinicalSyndromes(symptoms) {
        const syndromes = [];
        const symptomNames = symptoms.map(s => s.name.toLowerCase());
        
        const syndromePatterns = {
            'stroke_syndrome': {
                required: ['stroke'],
                optional: ['weakness', 'numbness', 'asthenia', 'hypoesthesia'],
                conditions: ['ischemic_stroke', 'hemorrhagic_stroke', 'transient_ischemic_attack']
            },
            'neurological_deficit': {
                required: ['weakness', 'numbness'],
                optional: ['asthenia', 'hypoesthesia'],
                conditions: ['stroke', 'multiple_sclerosis', 'peripheral_neuropathy']
            }
        };
        
        Object.entries(syndromePatterns).forEach(([syndromeName, pattern]) => {
            const match = this.matchSyndromePattern(symptomNames, pattern);
            if (match.score > 0.5) {
                pattern.conditions.forEach(condition => {
                    syndromes.push({
                        id: condition.replace(/\s+/g, '_'),
                        name: condition.replace(/_/g, ' '),
                        confidence: match.score * 0.9,
                        evidence: `clinical_syndrome_${syndromeName}`,
                        syndromeMatch: match
                    });
                });
            }
        });
        
        return syndromes;
    }
    
    matchSyndromePattern(symptomNames, pattern) {
        let score = 0;
        const matchedSymptoms = [];
        
        const requiredMatches = pattern.required.filter(required => {
            const found = symptomNames.some(symptom => 
                symptom.includes(required) || required.includes(symptom)
            );
            if (found) matchedSymptoms.push(required);
            return found;
        });
        
        if (requiredMatches.length === 0) {
            return { score: 0, matchedSymptoms: [] };
        }
        
        score = requiredMatches.length / pattern.required.length;
        
        if (pattern.optional) {
            const optionalMatches = pattern.optional.filter(optional =>
                symptomNames.some(symptom => symptom.includes(optional))
            );
            score += (optionalMatches.length / pattern.optional.length) * 0.3;
        }
        
        return { score: Math.min(score, 1.0), matchedSymptoms };
    }

    // ===== STAGE 4: BIOMEDICAL KNOWLEDGE INTEGRATION =====
    
    integrateBiomedicalKnowledge(symptoms) {
        const biomedicalMappings = [];
        
        if (!this.biomedicalKB) return biomedicalMappings;
        
        const kbConditions = this.extractFromBiomedicalConditions(symptoms);
        biomedicalMappings.push(...kbConditions);
        
        return biomedicalMappings;
    }
    
    extractFromBiomedicalConditions(symptoms) {
        const conditions = [];
        
        if (this.biomedicalKB.conditions) {
            Object.entries(this.biomedicalKB.conditions).forEach(([conditionId, conditionData]) => {
                const relevanceScore = this.calculateConditionRelevance(symptoms, conditionData);
                
                if (relevanceScore > 0.3) {
                    conditions.push({
                        id: conditionId,
                        name: conditionData.name || conditionId.replace(/_/g, ' '),
                        confidence: relevanceScore,
                        evidence: 'biomedical_kb_condition',
                        description: conditionData.properties?.description || '',
                        kbData: conditionData
                    });
                }
            });
        }
        
        return conditions;
    }
    
    calculateConditionRelevance(symptoms, conditionData) {
        let relevance = 0;
        const conditionText = (conditionData.name + ' ' + 
                             (conditionData.properties?.description || '')).toLowerCase();
        
        symptoms.forEach(symptom => {
            const symptomName = symptom.name.toLowerCase();
            
            if (conditionText.includes(symptomName) || symptomName.includes(conditionText)) {
                relevance += 0.5;
            }
            
            const symptomWords = symptomName.split(/\s+/);
            const conditionWords = conditionText.split(/\s+/);
            
            const overlap = symptomWords.filter(word => 
                word.length > 3 && conditionWords.some(cWord => 
                    cWord.includes(word) || word.includes(cWord)
                )
            );
            
            relevance += (overlap.length / symptomWords.length) * 0.3;
        });
        
        return Math.min(relevance, 1.0);
    }

    // ===== STAGE 5: MEDICAL REASONING SYNTHESIS =====
    
    synthesizeMedicalReasoning(ontologyMappings, knowledgeMappings, patternMappings, biomedicalMappings, symptoms) {
        const allMappings = [
            ...ontologyMappings,
            ...knowledgeMappings,
            ...patternMappings,
            ...biomedicalMappings
        ];
        
        const conditionMap = this.consolidateConditions(allMappings);
        const enhancedConditions = this.enhanceConditionsWithTreatments(conditionMap, symptoms);
        const reasonedConditions = this.applyClinicalReasoning(enhancedConditions, symptoms);
        
        return reasonedConditions
            .sort((a, b) => b.consolidatedConfidence - a.consolidatedConfidence)
            .slice(0, 6);
    }
    
    consolidateConditions(allMappings) {
        const conditionMap = new Map();
        
        allMappings.forEach(mapping => {
            const key = mapping.id;
            const existing = conditionMap.get(key);
            
            if (!existing) {
                conditionMap.set(key, {
                    ...mapping,
                    evidenceList: [mapping.evidence],
                    confidenceScores: [mapping.confidence],
                    consolidatedConfidence: mapping.confidence
                });
            } else {
                existing.evidenceList.push(mapping.evidence);
                existing.confidenceScores.push(mapping.confidence);
                
                const avgConfidence = existing.confidenceScores.reduce((a, b) => a + b, 0) / existing.confidenceScores.length;
                const evidenceBonus = Math.min(existing.evidenceList.length * 0.1, 0.4);
                existing.consolidatedConfidence = Math.min(avgConfidence + evidenceBonus, 0.95);
            }
        });
        
        return conditionMap;
    }
    
    enhanceConditionsWithTreatments(conditionMap, symptoms) {
        const enhancedConditions = [];
        
        for (const [conditionId, condition] of conditionMap) {
            const treatments = this.getTreatmentsForCondition(conditionId);
            const clinicalData = this.getClinicalDataForCondition(conditionId);
            
            enhancedConditions.push({
                id: conditionId,
                name: condition.name,
                description: condition.description || `Medical condition: ${condition.name}`,
                probability: condition.consolidatedConfidence,
                adjustedProbability: condition.consolidatedConfidence,
                evidenceStrength: condition.consolidatedConfidence,
                evidence: condition.evidenceList.map((evidence, index) => ({
                    type: evidence,
                    strength: condition.confidenceScores[index],
                    source: this.getEvidenceSource(evidence)
                })),
                supportingSymptoms: symptoms,
                treatments: treatments,
                ...clinicalData
            });
        }
        
        return enhancedConditions;
    }
    
    applyClinicalReasoning(conditions, symptoms) {
        return conditions.map(condition => {
            const clinicalScore = this.calculateClinicalScore(condition, symptoms);
            const anatomicalConsistency = this.validateAnatomicalConsistency(condition, symptoms);
            
            const reasoningAdjustment = (clinicalScore + anatomicalConsistency) / 2;
            const adjustedProbability = condition.probability * reasoningAdjustment;
            
            return {
                ...condition,
                probability: adjustedProbability,
                adjustedProbability: adjustedProbability,
                clinicalScore,
                anatomicalConsistency,
                consolidatedConfidence: adjustedProbability
            };
        }).filter(condition => condition.adjustedProbability > 0.2);
    }

    // ===== KNOWLEDGE BASE BUILDING =====
    
    buildCompleteHPOIndex() {
        const index = new Map();
        
        if (!this.hpoData?.graphs?.[0]?.nodes) return index;
        
        this.hpoData.graphs[0].nodes.forEach(node => {
            const hpoId = node.id.replace('http://purl.obolibrary.org/obo/', '');
            const name = node.lbl || node.label || '';
            const definition = node.meta?.definition?.val || '';
            const synonyms = node.meta?.synonyms?.map(s => s.val) || [];
            
            if (name) {
                index.set(hpoId, {
                    id: hpoId,
                    name: name.toLowerCase(),
                    definition,
                    synonyms: synonyms.map(s => s.toLowerCase()),
                    rawNode: node
                });
            }
        });
        
        console.log(`Built complete HPO index with ${index.size} concepts`);
        return index;
    }
    
    buildMedicalOntologyGraph() {
        const graph = new Map();
        
        if (!this.hpoData?.graphs?.[0]?.edges) return graph;
        
        this.hpoData.graphs[0].edges.forEach(edge => {
            const subject = edge.sub.replace('http://purl.obolibrary.org/obo/', '');
            const object = edge.obj.replace('http://purl.obolibrary.org/obo/', '');
            const predicate = edge.pred;
            
            if (!graph.has(subject)) {
                graph.set(subject, { parents: [], children: [], related: [] });
            }
            
            if (predicate === 'is_a') {
                graph.get(subject).parents.push(object);
            } else {
                graph.get(subject).related.push({ target: object, relation: predicate });
            }
        });
        
        return graph;
    }

    // ===== UTILITY METHODS =====
    
    getHPOParents(hpoId) {
        const node = this.medicalOntology.get(hpoId);
        return node ? node.parents : [];
    }
    
    getHPOChildren(hpoId) {
        const children = [];
        for (const [nodeId, node] of this.medicalOntology) {
            if (node.parents.includes(hpoId)) {
                children.push(nodeId);
            }
        }
        return children;
    }
    
    getHPORelationships(hpoId) {
        const node = this.medicalOntology.get(hpoId);
        return node ? node.related : [];
    }
    
    inferConditionsFromHPOTerm(hpoTerm) {
        const conditions = [];
        const text = (hpoTerm.name + ' ' + hpoTerm.definition).toLowerCase();
        
        const conditionIndicators = [
            /\b(\w+(?:\s+\w+)*?)\s+(?:disease|disorder|syndrome|condition)\b/g,
            /\b(?:associated with|due to|caused by)\s+(\w+(?:\s+\w+)*?)\b/g
        ];
        
        conditionIndicators.forEach(pattern => {
            let match;
            while ((match = pattern.exec(text)) !== null) {
                const conditionName = match[1].trim();
                if (conditionName.length > 3) {
                    conditions.push({
                        id: conditionName.replace(/\s+/g, '_'),
                        name: conditionName,
                        confidence: 0.6,
                        evidence: 'hpo_term_analysis'
                    });
                }
            }
        });
        
        return conditions;
    }
    
    createConditionFromText(conditionText, anatomicalSystem) {
        return {
            id: conditionText.replace(/\s+/g, '_'),
            name: conditionText,
            anatomicalSystem: anatomicalSystem,
            confidence: 0.7
        };
    }
    
    inferAnatomicalSystem(entityData) {
        const text = ((entityData.name || '') + ' ' + (entityData.definition || '')).toLowerCase();
        
        const systemKeywords = {
            'cardiovascular': ['heart', 'cardiac', 'blood', 'vessel', 'circulation', 'artery', 'vein'],
            'respiratory': ['lung', 'pulmonary', 'breathing', 'respiratory', 'airway'],
            'neurological': ['brain', 'neural', 'nerve', 'cognitive', 'motor', 'cerebral', 'spinal'],
            'gastrointestinal': ['stomach', 'intestinal', 'digestive', 'gastric', 'bowel', 'liver'],
            'genitourinary': ['kidney', 'renal', 'urinary', 'bladder', 'urine', 'nephro'],
            'musculoskeletal': ['muscle', 'bone', 'joint', 'skeletal', 'muscular'],
            'endocrine': ['hormone', 'gland', 'endocrine', 'thyroid', 'insulin']
        };
        
        for (const [system, keywords] of Object.entries(systemKeywords)) {
            if (keywords.some(keyword => text.includes(keyword))) {
                return system;
            }
        }
        
        return 'general';
    }
    
    getTreatmentsForCondition(conditionId) {
        const treatmentMap = {
            'ischemic_stroke': [
                { id: 'thrombolysis', name: 'Thrombolytic Therapy', efficacy: 0.85, cost: 15000, sideEffects: 0.25 },
                { id: 'antiplatelet', name: 'Antiplatelet Therapy', efficacy: 0.75, cost: 200, sideEffects: 0.15 },
                { id: 'rehabilitation', name: 'Stroke Rehabilitation', efficacy: 0.80, cost: 8000, sideEffects: 0.05 }
            ],
            'hemorrhagic_stroke': [
                { id: 'neurosurgery', name: 'Neurosurgical Intervention', efficacy: 0.70, cost: 50000, sideEffects: 0.35 },
                { id: 'blood_pressure_control', name: 'Blood Pressure Management', efficacy: 0.80, cost: 500, sideEffects: 0.20 }
            ],
            'stroke': [
                { id: 'emergency_care', name: 'Emergency Stroke Care', efficacy: 0.85, cost: 20000, sideEffects: 0.20 },
                { id: 'rehabilitation', name: 'Rehabilitation Therapy', efficacy: 0.75, cost: 10000, sideEffects: 0.10 }
            ],
            'myasthenia_gravis': [
                { id: 'acetylcholinesterase_inhibitors', name: 'Acetylcholinesterase Inhibitors', efficacy: 0.80, cost: 2000, sideEffects: 0.25 },
                { id: 'immunosuppression', name: 'Immunosuppressive Therapy', efficacy: 0.75, cost: 3000, sideEffects: 0.30 }
            ],
            'multiple_sclerosis': [
                { id: 'disease_modifying_therapy', name: 'Disease-Modifying Therapy', efficacy: 0.70, cost: 15000, sideEffects: 0.35 },
                { id: 'symptom_management', name: 'Symptom Management', efficacy: 0.65, cost: 2000, sideEffects: 0.20 }
            ],
            'peripheral_neuropathy': [
                { id: 'neuropathic_pain_treatment', name: 'Neuropathic Pain Treatment', efficacy: 0.70, cost: 1500, sideEffects: 0.25 },
                { id: 'physical_therapy', name: 'Physical Therapy', efficacy: 0.60, cost: 2000, sideEffects: 0.05 }
            ],
            'chronic_fatigue_syndrome': [
                { id: 'graded_exercise_therapy', name: 'Graded Exercise Therapy', efficacy: 0.60, cost: 1000, sideEffects: 0.10 },
                { id: 'cognitive_behavioral_therapy', name: 'Cognitive Behavioral Therapy', efficacy: 0.65, cost: 2000, sideEffects: 0.05 }
            ]
        };
        
        return treatmentMap[conditionId] || [
            { id: 'supportive_care', name: 'Supportive Care', efficacy: 0.60, cost: 1000, sideEffects: 0.05 },
            { id: 'symptom_management', name: 'Symptom Management', efficacy: 0.70, cost: 500, sideEffects: 0.10 }
        ];
    }
    
    getClinicalDataForCondition(conditionId) {
        const clinicalDataMap = {
            'ischemic_stroke': {
                severity: 'severe',
                prognosis: 'Variable; depends on extent and timing of treatment',
                chronicityRisk: 0.8,
                successRate: 0.75,
                baseCost: 15000,
                urgency: 'critical'
            },
            'hemorrhagic_stroke': {
                severity: 'severe',
                prognosis: 'Variable; higher mortality risk than ischemic stroke',
                chronicityRisk: 0.9,
                successRate: 0.65,
                baseCost: 30000,
                urgency: 'critical'
            },
            'stroke': {
                severity: 'severe',
                prognosis: 'Variable; significant rehabilitation potential with timely treatment',
                chronicityRisk: 0.8,
                successRate: 0.70,
                baseCost: 20000,
                urgency: 'critical'
            },
            'myasthenia_gravis': {
                severity: 'moderate_to_severe',
                prognosis: 'Good with appropriate treatment; manageable chronic condition',
                chronicityRisk: 0.9,
                successRate: 0.80,
                baseCost: 5000,
                urgency: 'moderate'
            },
            'multiple_sclerosis': {
                severity: 'moderate_to_severe',
                prognosis: 'Variable; disease-modifying therapies can slow progression',
                chronicityRisk: 0.95,
                successRate: 0.65,
                baseCost: 12000,
                urgency: 'moderate'
            },
            'peripheral_neuropathy': {
                severity: 'mild_to_moderate',
                prognosis: 'Variable; depends on underlying cause and treatment',
                chronicityRisk: 0.7,
                successRate: 0.70,
                baseCost: 3000,
                urgency: 'low'
            },
            'chronic_fatigue_syndrome': {
                severity: 'moderate',
                prognosis: 'Variable; some improvement with comprehensive management',
                chronicityRisk: 0.8,
                successRate: 0.60,
                baseCost: 2000,
                urgency: 'low'
            }
        };
        
        return clinicalDataMap[conditionId] || {
            severity: 'moderate',
            prognosis: 'Prognosis depends on timely intervention and individual factors',
            chronicityRisk: 0.5,
            successRate: 0.70,
            baseCost: 2000,
            urgency: 'moderate'
        };
    }
    
    calculateClinicalScore(condition, symptoms) {
        let score = 0.7;
        
        const relevantSymptoms = symptoms.filter(symptom => 
            this.isSymptomRelevantToCondition(symptom, condition)
        );
        
        if (relevantSymptoms.length > 0) {
            score += (relevantSymptoms.length / symptoms.length) * 0.3;
        }
        
        const evidenceQuality = this.assessEvidenceQuality(condition.evidence);
        score += evidenceQuality * 0.2;
        
        return Math.min(score, 1.0);
    }
    
    validateAnatomicalConsistency(condition, symptoms) {
        const conditionSystem = this.getAnatomicalSystemForCondition(condition.name);
        const symptomSystems = symptoms.map(s => this.inferAnatomicalSystem(s));
        
        const systemMatches = symptomSystems.filter(system => 
            system === conditionSystem || system === 'general'
        );
        
        return systemMatches.length / symptoms.length;
    }
    
    isSymptomRelevantToCondition(symptom, condition) {
        const symptomName = symptom.name.toLowerCase();
        const conditionName = condition.name.toLowerCase();
        const conditionDescription = (condition.description || '').toLowerCase();
        
        if (conditionName.includes(symptomName) || conditionDescription.includes(symptomName)) {
            return true;
        }
        
        const symptomSystem = this.inferAnatomicalSystem(symptom);
        const conditionSystem = this.getAnatomicalSystemForCondition(condition.name);
        
        return symptomSystem === conditionSystem;
    }
    
    getAnatomicalSystemForCondition(conditionName) {
        const name = conditionName.toLowerCase();
        
        if (/stroke|cerebral|brain|neural|neuro/.test(name)) return 'neurological';
        if (/heart|cardiac|myocardial|coronary/.test(name)) return 'cardiovascular';
        if (/kidney|renal|urinary|stone|nephro/.test(name)) return 'genitourinary';
        if (/gastro|intestinal|bowel|stomach|appendix/.test(name)) return 'gastrointestinal';
        if (/lung|pulmonary|respiratory/.test(name)) return 'respiratory';
        if (/muscle|bone|joint|skeletal/.test(name)) return 'musculoskeletal';
        
        return 'general';
    }
    
    assessEvidenceQuality(evidenceList) {
        if (!evidenceList || evidenceList.length === 0) return 0.5;
        
        const evidenceWeights = {
            'hpo_definition': 0.9,
            'clinical_syndrome': 0.8,
            'medical_terminology': 0.7,
            'pathophysiology_mapping': 0.8,
            'anatomical_correlation': 0.6,
            'hpo_relationship': 0.5,
            'biomedical_kb_condition': 0.7
        };
        
        const totalWeight = evidenceList.reduce((sum, evidence) => {
            const weight = evidenceWeights[evidence.type] || 0.5;
            return sum + (weight * evidence.strength);
        }, 0);
        
        return Math.min(totalWeight / evidenceList.length, 1.0);
    }
    
    getEvidenceSource(evidenceType) {
        const sourceMap = {
            'hpo_definition': 'HPO Ontology Definition',
            'hpo_relationship': 'HPO Relationship Graph',
            'clinical_syndrome': 'Clinical Pattern Recognition',
            'medical_terminology': 'Medical Terminology Analysis',
            'pathophysiology_mapping': 'Pathophysiology Analysis',
            'anatomical_correlation': 'Anatomical System Correlation',
            'biomedical_kb_condition': 'Biomedical Knowledge Base'
        };
        
        return sourceMap[evidenceType] || 'Medical Knowledge';
    }
    
    generateFallbackConditions(symptoms) {
        console.log('Generating fallback conditions for symptoms:', symptoms.map(s => s.name));
        
        const fallbackConditions = [];
        
        symptoms.forEach(symptom => {
            const symptomName = symptom.name.toLowerCase();
            
            // Simple fallback mapping
            if (symptomName.includes('stroke')) {
                fallbackConditions.push({
                    id: 'stroke_condition',
                    name: 'Stroke Condition',
                    description: 'Cerebrovascular accident requiring immediate medical attention',
                    probability: 0.8,
                    adjustedProbability: 0.8,
                    evidenceStrength: 0.8,
                    evidence: [{ type: 'fallback_mapping', strength: 0.8, source: 'Fallback System' }],
                    supportingSymptoms: [symptom],
                    treatments: this.getTreatmentsForCondition('stroke'),
                    ...this.getClinicalDataForCondition('stroke')
                });
            } else if (symptomName.includes('weakness') || symptomName.includes('asthenia')) {
                fallbackConditions.push({
                    id: 'neuromuscular_disorder',
                    name: 'Neuromuscular Disorder',
                    description: 'Condition affecting muscle strength and function',
                    probability: 0.6,
                    adjustedProbability: 0.6,
                    evidenceStrength: 0.6,
                    evidence: [{ type: 'fallback_mapping', strength: 0.6, source: 'Fallback System' }],
                    supportingSymptoms: [symptom],
                    treatments: this.getTreatmentsForCondition('myasthenia_gravis'),
                    severity: 'moderate',
                    prognosis: 'Variable depending on specific condition and treatment',
                    chronicityRisk: 0.6,
                    successRate: 0.70,
                    baseCost: 3000,
                    urgency: 'moderate'
                });
            } else if (symptomName.includes('numbness') || symptomName.includes('hypoesthesia')) {
                fallbackConditions.push({
                    id: 'sensory_neuropathy',
                    name: 'Sensory Neuropathy',
                    description: 'Condition affecting sensory nerve function',
                    probability: 0.6,
                    adjustedProbability: 0.6,
                    evidenceStrength: 0.6,
                    evidence: [{ type: 'fallback_mapping', strength: 0.6, source: 'Fallback System' }],
                    supportingSymptoms: [symptom],
                    treatments: this.getTreatmentsForCondition('peripheral_neuropathy'),
                    severity: 'mild_to_moderate',
                    prognosis: 'Good with appropriate treatment and management',
                    chronicityRisk: 0.7,
                    successRate: 0.70,
                    baseCost: 2000,
                    urgency: 'low'
                });
            }
        });
        
        // If no specific conditions found, add a general neurological condition
        if (fallbackConditions.length === 0) {
            fallbackConditions.push({
                id: 'neurological_symptoms',
                name: 'Neurological Symptoms',
                description: 'Constellation of neurological symptoms requiring evaluation',
                probability: 0.5,
                adjustedProbability: 0.5,
                evidenceStrength: 0.5,
                evidence: [{ type: 'fallback_mapping', strength: 0.5, source: 'Fallback System' }],
                supportingSymptoms: symptoms,
                treatments: [
                    { id: 'neurological_evaluation', name: 'Neurological Evaluation', efficacy: 0.80, cost: 2000, sideEffects: 0.05 },
                    { id: 'supportive_care', name: 'Supportive Care', efficacy: 0.60, cost: 1000, sideEffects: 0.05 }
                ],
                severity: 'moderate',
                prognosis: 'Requires comprehensive neurological evaluation for diagnosis',
                chronicityRisk: 0.5,
                successRate: 0.75,
                baseCost: 2000,
                urgency: 'moderate'
            });
        }
        
        console.log('Generated fallback conditions:', fallbackConditions.length);
        return fallbackConditions;
    }
    
    extractClinicalContext(hpoInfo) {
        const context = {};
        
        if (hpoInfo.definition) {
            const definition = hpoInfo.definition.toLowerCase();
            
            if (/infant|child|pediatric|neonatal/.test(definition)) {
                context.ageGroup = 'pediatric';
            } else if (/elderly|geriatric|old/.test(definition)) {
                context.ageGroup = 'geriatric';
            }
            
            if (/severe|critical|life-threatening/.test(definition)) {
                context.severity = 'severe';
            } else if (/mild|minor|slight/.test(definition)) {
                context.severity = 'mild';
            }
            
            if (/acute|sudden|rapid/.test(definition)) {
                context.timing = 'acute';
            } else if (/chronic|persistent|long-term/.test(definition)) {
                context.timing = 'chronic';
            }
        }
        
        return context;
    }
}



// INSERT CLINICAL NARRATIVE BUILDER CLASS HERE
// (Copy the entire ClinicalNarrativeBuilder class from artifact 3)
// Clinical Narrative Builder - Creates V.1 style comprehensive clinical narratives
class ClinicalNarrativeBuilder {
    constructor() {
        this.statisticsCalculator = new StatisticsCalculator();
    }

    buildComprehensiveClinicalWorkflow(detectedSymptoms, mappedConditions, clinicalContext) {
        let nodeId = 0;
        
        // Build symptom complex summary
        const symptomComplex = this.buildSymptomComplex(detectedSymptoms, clinicalContext);
        
        // Root node - Symptom Complex
        const rootNode = {
            id: nodeId++,
            type: 'symptom',
            title: 'Symptom Complex',
            description: this.generateSymptomComplexDescription(detectedSymptoms, clinicalContext),
            children: [],
            metadata: {
                symptoms: detectedSymptoms,
                clinicalContext,
                severity: this.calculateOverallSeverity(detectedSymptoms),
                chronicityRisk: this.calculateChronicityRisk(detectedSymptoms, clinicalContext),
                confidence: this.calculateOverallConfidence(detectedSymptoms, mappedConditions)
            }
        };

        // Build condition branches
        mappedConditions.forEach(condition => {
            const diagnosisNode = this.buildDiagnosisNode(condition, nodeId++);
            
            // Build treatment branches for this condition
            if (condition.treatments && condition.treatments.length > 0) {
                condition.treatments.forEach(treatment => {
                    const treatmentNode = this.buildTreatmentNode(treatment, condition, nodeId++);
                    const outcomeNode = this.buildOutcomeNode(treatment, condition, nodeId++);
                    
                    treatmentNode.children.push(outcomeNode);
                    diagnosisNode.children.push(treatmentNode);
                });
            }
            
            rootNode.children.push(diagnosisNode);
        });

        return rootNode;
    }

    buildSymptomComplex(symptoms, context) {
        const primary = symptoms.slice(0, 4); // Top 4 symptoms
        const severities = {};
        
        primary.forEach(symptom => {
            severities[symptom.name] = symptom.severity;
        });

        return {
            primarySymptoms: primary.map(s => s.name),
            severities,
            temporalPattern: this.determineTemporalPattern(symptoms),
            clinicalModifiers: this.extractClinicalModifiers(context)
        };
    }

    generateSymptomComplexDescription(symptoms, context) {
        const symptomNames = symptoms.map(s => s.name).join(', ');
        const severityInfo = symptoms.map(s => `${s.name}: ${s.severity}`).join(', ');
        
        let description = `${symptomNames} with ${severityInfo}`;
        
        if (context.timing) {
            description += `. Timing: ${context.timing}`;
        }
        if (context.duration) {
            description += `. Duration: ${context.duration}`;
        }
        if (context.frequency) {
            description += `. Frequency: ${context.frequency}`;
        }

        return description;
    }

    buildDiagnosisNode(condition, nodeId) {
        return {
            id: nodeId,
            type: 'diagnosis',
            title: condition.name.toUpperCase(),
            description: this.generateDiagnosisDescription(condition),
            children: [],
            metadata: {
                probability: condition.probability,
                adjustedProbability: condition.adjustedProbability,
                severity: condition.severity,
                chronicityRisk: condition.chronicityRisk,
                evidence: condition.evidence,
                supportingSymptoms: condition.supportingSymptoms,
                prognosis: condition.prognosis
            }
        };
    }

    generateDiagnosisDescription(condition) {
        let description = condition.prognosis || 'Standard medical management recommended';
        
        if (condition.evidence && condition.evidence.length > 0) {
            const evidenceStrength = (condition.evidenceStrength * 100).toFixed(1);
            description += `. Evidence strength: ${evidenceStrength}%`;
        }
        
        if (condition.supportingSymptoms && condition.supportingSymptoms.length > 0) {
            const supportingNames = condition.supportingSymptoms.map(s => s.name).join(', ');
            description += `. Supporting symptoms: ${supportingNames}`;
        }

        return description;
    }

    buildTreatmentNode(treatment, condition, nodeId) {
        return {
            id: nodeId,
            type: 'treatment',
            title: treatment.name.toUpperCase(),
            description: this.generateTreatmentDescription(treatment, condition),
            children: [],
            metadata: {
                efficacy: treatment.efficacy,
                cost: treatment.cost,
                sideEffects: treatment.sideEffects,
                contraindications: treatment.contraindications,
                evidenceLevel: this.calculateTreatmentEvidenceLevel(treatment, condition),
                clinicalRecommendation: this.generateClinicalRecommendation(treatment, condition)
            }
        };
    }

    generateTreatmentDescription(treatment, condition) {
        let description = treatment.description || `${treatment.name} therapy`;
        
        if (treatment.contraindications && treatment.contraindications.length > 0) {
            description += `. Contraindications: ${treatment.contraindications.join(', ')}`;
        }
        
        const recommendation = this.generateClinicalRecommendation(treatment, condition);
        description += `. ${recommendation}`;

        return description;
    }

    buildOutcomeNode(treatment, condition, nodeId) {
        const statistics = this.runEnhancedSimulations(treatment, condition);
        
        return {
            id: nodeId,
            type: 'outcome',
            title: 'Expected Outcome',
            description: this.generateOutcomeDescription(treatment, condition, statistics),
            enhancedStatistics: statistics,
            metadata: {
                prognosis: condition.prognosis,
                severity: condition.severity,
                chronicityRisk: condition.chronicityRisk,
                timeToImprovement: this.estimateTimeToImprovement(treatment, condition),
                qualityOfLifeImpact: this.calculateQualityOfLifeImpact(statistics, condition),
                followUpRecommendations: this.generateFollowUpRecommendations(treatment, condition)
            }
        };
    }

    generateOutcomeDescription(treatment, condition, statistics) {
        const successRate = (statistics.success.mean * 100).toFixed(1);
        const costEstimate = Math.round(statistics.cost.mean);
        const sideEffectRisk = (treatment.sideEffects * 100).toFixed(1);
        
        let description = `${condition.prognosis}. `;
        description += `Expected success rate: ${successRate}%. `;
        description += `Total cost estimate: $${costEstimate}. `;
        description += `Side effect probability: ${sideEffectRisk}%`;

        return description;
    }

    runEnhancedSimulations(treatment, condition, numSimulations = 20) {
        const successValues = [];
        const costValues = [];
        const costBreakdown = {
            monetary: [],
            pain: [],
            emotional: [],
            social: [],
            time: []
        };

        for (let i = 0; i < numSimulations; i++) {
            // Environmental and patient variation factors
            const envFactor = 1 + (Math.random() - 0.5) * 0.3;
            const patientFactor = 1 + (Math.random() - 0.5) * 0.25;
            const complexityFactor = this.getComplexityFactor(condition);

            // Success calculation
            const baseSuccess = treatment.efficacy * 0.85; // Assume 85% base condition success rate
            const adjustedSuccess = Math.max(0, Math.min(1, 
                baseSuccess * envFactor * patientFactor * complexityFactor
            ));
            successValues.push(adjustedSuccess);

            // Cost calculations with realistic variation
            const baseCost = treatment.cost || 500;
            const monetaryVariation = baseCost * (1 + (Math.random() - 0.5) * 0.4);
            costBreakdown.monetary.push(Math.max(0, monetaryVariation));

            // Pain level (0-10 scale)
            const painLevel = this.calculatePainLevel(treatment, condition);
            const painVariation = painLevel * (1 + (Math.random() - 0.5) * 0.3);
            costBreakdown.pain.push(Math.max(0, painVariation));

            // Emotional stress (0-10 scale)
            const emotionalStress = this.calculateEmotionalStress(treatment, condition);
            const emotionalVariation = emotionalStress * (1 + (Math.random() - 0.5) * 0.35);
            costBreakdown.emotional.push(Math.max(0, emotionalVariation));

            // Social impact (0-10 scale)
            const socialImpact = this.calculateSocialImpact(treatment, condition);
            const socialVariation = socialImpact * (1 + (Math.random() - 0.5) * 0.25);
            costBreakdown.social.push(Math.max(0, socialVariation));

            // Time commitment (weeks)
            const timeCommitment = this.calculateTimeCommitment(treatment, condition);
            const timeVariation = timeCommitment * (1 + (Math.random() - 0.5) * 0.2);
            costBreakdown.time.push(Math.max(0, timeVariation));

            // Total weighted cost
            const totalCost = monetaryVariation + 
                            (painVariation * 200) + 
                            (emotionalVariation * 150) + 
                            (socialVariation * 100) + 
                            (timeVariation * 50);
            costValues.push(totalCost);
        }

        return {
            success: this.statisticsCalculator.calculateStatistics(successValues),
            cost: this.statisticsCalculator.calculateStatistics(costValues),
            costBreakdown: {
                monetary: this.statisticsCalculator.calculateStatistics(costBreakdown.monetary),
                pain: this.statisticsCalculator.calculateStatistics(costBreakdown.pain),
                emotional: this.statisticsCalculator.calculateStatistics(costBreakdown.emotional),
                social: this.statisticsCalculator.calculateStatistics(costBreakdown.social),
                time: this.statisticsCalculator.calculateStatistics(costBreakdown.time)
            }
        };
    }

    // Utility methods for clinical calculations
    getComplexityFactor(condition) {
        if (condition.severity === 'severe') return 0.8;
        if (condition.severity === 'moderate') return 0.9;
        return 1.0;
    }

    calculatePainLevel(treatment, condition) {
        const treatmentPain = {
            'surgical_removal': 7,
            'lithotripsy': 4,
            'cystoscopy': 3,
            'antibiotics': 0,
            'pain_management': 1,
            'supportive_care': 0
        };
        return treatmentPain[treatment.id] || 2;
    }

    calculateEmotionalStress(treatment, condition) {
        const baseStress = condition.severity === 'severe' ? 4 : 2;
        const treatmentStress = {
            'surgical_removal': 5,
            'lithotripsy': 3,
            'cystoscopy': 3,
            'antibiotics': 1,
            'pain_management': 1,
            'supportive_care': 1
        };
        return baseStress + (treatmentStress[treatment.id] || 1);
    }

    calculateSocialImpact(treatment, condition) {
        const treatmentImpact = {
            'surgical_removal': 4,
            'lithotripsy': 2,
            'cystoscopy': 1,
            'antibiotics': 0,
            'pain_management': 1,
            'supportive_care': 0
        };
        return treatmentImpact[treatment.id] || 1;
    }

    calculateTimeCommitment(treatment, condition) {
        const treatmentTime = {
            'surgical_removal': 8,
            'lithotripsy': 4,
            'cystoscopy': 2,
            'antibiotics': 1,
            'pain_management': 2,
            'supportive_care': 2
        };
        return treatmentTime[treatment.id] || 2;
    }

    calculateTreatmentEvidenceLevel(treatment, condition) {
        const efficacy = treatment.efficacy || 0.7;
        const conditionMatch = condition.evidenceStrength || 0.7;
        
        const combined = efficacy * conditionMatch;
        
        if (combined > 0.8) return 'High';
        if (combined > 0.6) return 'Moderate-High';
        if (combined > 0.4) return 'Moderate';
        return 'Low-Moderate';
    }

    generateClinicalRecommendation(treatment, condition) {
        const efficacy = treatment.efficacy || 0.7;
        const cost = treatment.cost || 500;
        const sideEffects = treatment.sideEffects || 0.2;
        
        if (efficacy > 0.85 && cost < 1000 && sideEffects < 0.15) {
            return "Highly recommended first-line treatment with excellent safety profile";
        } else if (efficacy > 0.75 && cost < 3000 && sideEffects < 0.25) {
            return "Recommended treatment option with good efficacy and acceptable risk";
        } else if (efficacy > 0.65) {
            return "Consider as alternative treatment option";
        } else {
            return "Consider only if other options are unsuccessful or contraindicated";
        }
    }

    estimateTimeToImprovement(treatment, condition) {
        const timeMap = {
            'pain_management': '30-60 minutes for symptom relief',
            'antibiotics': '24-48 hours for infection improvement',
            'supportive_care': '3-7 days for symptomatic improvement',
            'lithotripsy': '1-2 weeks for stone passage',
            'surgical_removal': '2-4 weeks for full recovery',
            'cystoscopy': '24-48 hours for procedure recovery'
        };
        
        return timeMap[treatment.id] || 'Variable based on individual response and condition severity';
    }

    calculateQualityOfLifeImpact(statistics, condition) {
        let qolScore = statistics.success.mean * 100;
        
        // Adjust for treatment burden
        qolScore -= (statistics.costBreakdown.pain.mean * 8);
        qolScore -= (statistics.costBreakdown.emotional.mean * 6);
        qolScore -= (statistics.costBreakdown.social.mean * 4);
        qolScore -= (statistics.costBreakdown.time.mean * 2);
        
        // Adjust for condition severity
        if (condition.severity === 'severe') qolScore -= 10;
        if (condition.chronicityRisk > 0.5) qolScore -= 15;
        
        if (qolScore > 85) return 'Significant improvement in quality of life expected';
        if (qolScore > 70) return 'Good improvement in quality of life expected';
        if (qolScore > 55) return 'Moderate improvement in quality of life expected';
        if (qolScore > 40) return 'Some improvement in quality of life expected';
        return 'Limited improvement in quality of life expected';
    }

    generateFollowUpRecommendations(treatment, condition) {
        const recommendations = [];
        
        // Condition-specific recommendations
        if (condition.id === 'kidney_stones') {
            recommendations.push('Increase fluid intake to 2-3 liters daily');
            recommendations.push('Follow up with urology in 2-4 weeks');
            recommendations.push('Consider metabolic stone workup if recurrent');
        } else if (condition.id === 'urinary_tract_infection') {
            recommendations.push('Complete full antibiotic course even if symptoms improve');
            recommendations.push('Follow up if symptoms persist after 48-72 hours of treatment');
            recommendations.push('Consider prophylaxis if recurrent infections');
        } else if (condition.id === 'migraine') {
            recommendations.push('Keep headache diary to identify triggers');
            recommendations.push('Follow up in 4-6 weeks to assess treatment response');
            recommendations.push('Consider preventive therapy if frequent episodes');
        }
        
        // Treatment-specific recommendations
        if (treatment.sideEffects > 0.3) {
            recommendations.push('Monitor for side effects and contact provider if concerning symptoms develop');
        }
        
        if (treatment.contraindications && treatment.contraindications.length > 0) {
            recommendations.push('Inform all healthcare providers of this treatment before procedures');
        }
        
        // General recommendations
        recommendations.push('Return for evaluation if symptoms worsen or do not improve as expected');
        
        return recommendations;
    }

    // Overall assessment methods
    calculateOverallSeverity(symptoms) {
        const severities = symptoms.map(s => s.severity);
        const severeCounts = severities.filter(s => s === 'severe').length;
        const moderateCounts = severities.filter(s => s === 'moderate').length;
        
        if (severeCounts > 0) return 'severe';
        if (moderateCounts > severities.length / 2) return 'moderate';
        return 'mild';
    }

    calculateChronicityRisk(symptoms, context) {
        let risk = 0.3; // Base risk
        
        // Increase for chronic temporal patterns
        if (symptoms.some(s => s.temporal === 'chronic')) risk += 0.3;
        
        // Increase for long duration
        if (context.duration && /week|month|year/.test(context.duration)) risk += 0.2;
        
        // Increase for frequent symptoms
        if (context.frequency === 'daily') risk += 0.2;
        
        return Math.min(risk, 1.0);
    }

    calculateOverallConfidence(symptoms, conditions) {
        if (symptoms.length === 0) return 0;
        
        const avgSymptomConfidence = symptoms.reduce((sum, s) => sum + s.confidence, 0) / symptoms.length;
        const conditionBonus = Math.min(conditions.length * 0.1, 0.3);
        const evidenceBonus = conditions.length > 0 ? 
            Math.min(conditions.reduce((sum, c) => sum + c.evidenceStrength, 0) / conditions.length * 0.2, 0.2) : 0;
        
        return Math.min(avgSymptomConfidence + conditionBonus + evidenceBonus, 1.0);
    }

    determineTemporalPattern(symptoms) {
        const patterns = symptoms.map(s => s.temporal);
        const chronics = patterns.filter(p => p === 'chronic').length;
        const acutes = patterns.filter(p => p === 'acute').length;
        
        if (chronics > acutes) return 'chronic';
        if (acutes > 0) return 'acute';
        return 'subacute';
    }

    extractClinicalModifiers(context) {
        const modifiers = [];
        
        if (context.timing) modifiers.push(`Timing: ${context.timing}`);
        if (context.frequency) modifiers.push(`Frequency: ${context.frequency}`);
        if (context.duration) modifiers.push(`Duration: ${context.duration}`);
        if (context.systemicSigns) modifiers.push(`Systemic signs: ${context.systemicSigns.join(', ')}`);
        
        return modifiers;
    }
}

// Statistics Calculator utility class
class StatisticsCalculator {
    calculateStatistics(values) {
        if (!values || values.length === 0) {
            return { mean: 0, se: 0, min: 0, max: 0, std: 0 };
        }
        
        const mean = values.reduce((a, b) => a + b, 0) / values.length;
        const variance = values.reduce((acc, val) => acc + Math.pow(val - mean, 2), 0) / values.length;
        const std = Math.sqrt(variance);
        const se = std / Math.sqrt(values.length);
        
        return {
            mean,
            se,
            min: Math.min(...values),
            max: Math.max(...values),
            std
        };
    }
}


// Enhanced Clinical Intelligence Engine with Dynamic Components
class EnhancedClinicalIntelligenceEngine {
    constructor() {
        this.isReady = false;
        this.hpoData = null;
        this.biomedicalKB = null;
        this.symptomDetector = null;
        this.conditionMapper = null;
        this.narrativeBuilder = null;
        this.initialize();
    }

    async initialize() {
        try {
            await this.loadKnowledgeBasesRobustly();
            this.initializeProcessors();
            this.isReady = true;
            console.log('Enhanced Clinical Intelligence Engine ready');
            console.log(`Symptoms indexed: ${this.symptomDetector?.symptomIndex?.size || 0}`);
            console.log(`Conditions indexed: ${this.conditionMapper?.conditionIndex?.size || 0}`);
        } catch (error) {
            console.warn('Using fallback data due to:', error);
            this.initializeFallbackProcessors();
            this.isReady = true;
        }
    }

    async loadKnowledgeBasesRobustly() {
        // HPO Loading with multiple fallback strategies
        try {
            const hpoResponse = await fetch('assets/hp.json');
            if (hpoResponse.ok) {
                this.hpoData = await hpoResponse.json();
                console.log('HPO data loaded successfully');
            } else {
                throw new Error('HPO not available');
            }
        } catch (error) {
            console.log('HPO not available, using sample data');
            this.hpoData = this.createSampleHPOData();
        }

        // Biomedical KB with multiple format support
        try {
            const kbJsonResponse = await fetch('assets/Biomedical_Knowledgebase.json');
            if (kbJsonResponse.ok) {
                this.biomedicalKB = await kbJsonResponse.json();
                console.log('Biomedical KB loaded from JSON');
            } else {
                const txtResponse = await fetch('assets/Biomedical_Knowledgebase.txt');
                if (txtResponse.ok) {
                    const text = await txtResponse.text();
                    this.biomedicalKB = await this.parseTextKB(text);
                    console.log('Biomedical KB parsed from text');
                } else {
                    throw new Error('KB not available');
                }
            }
        } catch (error) {
            console.log('Biomedical KB not available, using fallback');
            this.biomedicalKB = this.createFallbackKB();
        }
    }

initializeProcessors() {
    // Initialize with fully dynamic processors
	// In EnhancedClinicalIntelligenceEngine.initializeProcessors()
	this.symptomDetector = new ScientificSymptomDetector(this.hpoData, this.biomedicalKB);
	// In EnhancedClinicalIntelligenceEngine.initializeProcessors()
	this.conditionMapper = new UniversalMedicalMapper(this.biomedicalKB, this.hpoData);
    this.narrativeBuilder = new ClinicalNarrativeBuilder();
    
    console.log('Fully dynamic processors initialized');
}

initializeFallbackProcessors() {
    // Even fallback uses dynamic extraction
    const fallbackHPO = this.createSampleHPOData();
    const fallbackKB = this.createFallbackKB();
    
	// In EnhancedClinicalIntelligenceEngine.initializeProcessors()
	this.symptomDetector = new ScientificSymptomDetector(this.hpoData, this.biomedicalKB);
	// In EnhancedClinicalIntelligenceEngine.initializeProcessors()
	this.conditionMapper = new UniversalMedicalMapper(this.biomedicalKB, this.hpoData);
    this.narrativeBuilder = new ClinicalNarrativeBuilder();
}

generateTreatmentPaths(conditions) {
    const paths = [];
    
    conditions.forEach(condition => {
        if (condition.treatments && condition.treatments.length > 0) {
            condition.treatments.forEach(treatment => {
                // Ensure treatment has required properties
                const enhancedTreatment = this.enhanceTreatment(treatment);
                const statistics = this.narrativeBuilder.runEnhancedSimulations(enhancedTreatment, condition);
                
                paths.push({
                    condition,
                    treatment: enhancedTreatment,
                    statistics,
                    evidenceLevel: this.calculateEvidenceLevel(condition, enhancedTreatment),
                    clinicalRecommendation: this.generateClinicalRecommendation(condition, enhancedTreatment)
                });
            });
        } else {
            // Generate default supportive care if no specific treatments found
            const defaultTreatment = this.createDefaultTreatment(condition);
            const statistics = this.narrativeBuilder.runEnhancedSimulations(defaultTreatment, condition);
            
            paths.push({
                condition,
                treatment: defaultTreatment,
                statistics,
                evidenceLevel: 'Low-Moderate',
                clinicalRecommendation: 'Standard supportive care and monitoring recommended'
            });
        }
    });
    
    return paths;
}

enhanceTreatment(treatment) {
    return {
        id: treatment.id || treatment.treatmentId,
        name: treatment.name || 'Standard Treatment',
        description: treatment.description || treatment.context || 'Standard medical management',
        efficacy: treatment.efficacy || 0.7,
        cost: treatment.cost || 1000,
        sideEffects: treatment.sideEffects || 0.2,
        contraindications: treatment.contraindications || [],
        painLevel: this.estimatePainLevel(treatment),
        emotionalStress: this.estimateEmotionalStress(treatment),
        socialImpact: this.estimateSocialImpact(treatment),
        timeCommitment: this.estimateTimeCommitment(treatment)
    };
}

createDefaultTreatment(condition) {
    return {
        id: 'supportive_care',
        name: 'Supportive Care',
        description: `Standard supportive care for ${condition.name}`,
        efficacy: 0.7,
        cost: 500,
        sideEffects: 0.05,
        contraindications: [],
        painLevel: 0,
        emotionalStress: 1,
        socialImpact: 0,
        timeCommitment: 2
    };
}

estimatePainLevel(treatment) {
    const name = treatment.name.toLowerCase();
    if (/surgery|operation|transplant/.test(name)) return 6;
    if (/injection|procedure/.test(name)) return 3;
    if (/medication|therapy/.test(name)) return 1;
    return 0;
}

estimateEmotionalStress(treatment) {
    const name = treatment.name.toLowerCase();
    if (/surgery|transplant|cancer/.test(name)) return 7;
    if (/procedure|therapy/.test(name)) return 3;
    if (/medication/.test(name)) return 1;
    return 2;
}

estimateSocialImpact(treatment) {
    const name = treatment.name.toLowerCase();
    if (/surgery|transplant/.test(name)) return 5;
    if (/therapy|procedure/.test(name)) return 2;
    return 0;
}

estimateTimeCommitment(treatment) {
    const name = treatment.name.toLowerCase();
    if (/surgery|transplant/.test(name)) return 12;
    if (/therapy|procedure/.test(name)) return 4;
    if (/medication/.test(name)) return 2;
    return 1;
}

    // Main analysis method
    async analyzeClinicalPresentation(text) {
        if (!this.isReady) {
            throw new Error('Clinical engine not ready');
        }

        console.log('=== Starting Enhanced Clinical Analysis ===');
        console.log('Input text:', text);

        // Step 1: Dynamic symptom detection
        const detectedSymptoms = this.symptomDetector.detectSymptoms(text);
        console.log('Detected symptoms:', detectedSymptoms);

        // Step 2: Extract clinical context
        const clinicalContext = this.extractClinicalContext(text);
        console.log('Clinical context:', clinicalContext);

        // Step 3: Map symptoms to conditions
        const mappedConditions = this.conditionMapper.mapSymptomsToConditions(detectedSymptoms);
        console.log('Mapped conditions:', mappedConditions);

        // Step 4: Build comprehensive clinical workflow
        const clinicalWorkflow = this.narrativeBuilder.buildComprehensiveClinicalWorkflow(
            detectedSymptoms, 
            mappedConditions, 
            clinicalContext
        );

        const result = {
            symptoms: detectedSymptoms,
            clinicalContext,
            conditions: mappedConditions,
            workflow: clinicalWorkflow,
            confidence: this.narrativeBuilder.calculateOverallConfidence(detectedSymptoms, mappedConditions)
        };

        console.log('=== Analysis Complete ===');
        console.log('Final result:', result);

        return result;
    }

    extractClinicalContext(text) {
        const lowerText = text.toLowerCase();
        const context = {};
        
        // Timing patterns
        if (/\b(morning|wake|dawn|am)\b/.test(lowerText)) {
            context.timing = 'morning';
        } else if (/\b(evening|night|pm)\b/.test(lowerText)) {
            context.timing = 'evening';
        }
        
        // Frequency patterns
        if (/\b(every day|daily)\b/.test(lowerText)) {
            context.frequency = 'daily';
        } else if (/\b(frequent|often)\b/.test(lowerText)) {
            context.frequency = 'frequent';
        }
        
        // Duration patterns
        if (/\b(\d+)\s*(week|weeks)\b/.test(lowerText)) {
            context.duration = 'weeks';
        } else if (/\b(\d+)\s*(month|months)\b/.test(lowerText)) {
            context.duration = 'months';
        }
        
        // Systemic signs
        if (/\b(fever|temperature)\b/.test(lowerText)) {
            context.systemicSigns = context.systemicSigns || [];
            context.systemicSigns.push('fever');
        }
        
        // Patient presentation language
        if (/\b(patient|presents|history)\b/.test(lowerText)) {
            context.clinicalPresentation = true;
        }
        
        return context;
    }

    // Fallback data creators
    createSampleHPOData() {
        return {
            graphs: [{
                nodes: [
                    {
                        id: "http://purl.obolibrary.org/obo/HP_0000790",
                        lbl: "Hematuria",
                        meta: {
                            definition: { val: "The presence of blood in the urine" },
                            synonyms: [
                                { val: "Blood in urine" },
                                { val: "Bloody urine" }
                            ]
                        }
                    },
                    {
                        id: "http://purl.obolibrary.org/obo/HP_0012330",
                        lbl: "Renal pain",
                        meta: {
                            definition: { val: "Pain originating from the kidney" },
                            synonyms: [
                                { val: "Kidney pain" },
                                { val: "Flank pain" },
                                { val: "Nephralgia" }
                            ]
                        }
                    },
                    {
                        id: "http://purl.obolibrary.org/obo/HP_0002315",
                        lbl: "Headache",
                        meta: {
                            definition: { val: "Pain in the head or neck region" },
                            synonyms: [
                                { val: "Head pain" },
                                { val: "Cephalgia" }
                            ]
                        }
                    },
                    {
                        id: "http://purl.obolibrary.org/obo/HP_0100749",
                        lbl: "Chest pain",
                        meta: {
                            definition: { val: "Pain in the chest" },
                            synonyms: [
                                { val: "Thoracic pain" }
                            ]
                        }
                    }
                ]
            }]
        };
    }

    createFallbackKB() {
        return {
            symptoms: {
                'hematuria': {
                    name: 'Hematuria',
                    properties: {
                        description: 'Presence of blood in urine',
                        associated_conditions: ['kidney_stones', 'urinary_tract_infection', 'bladder_cancer']
                    }
                },
                'kidney_pain': {
                    name: 'Kidney Pain',
                    properties: {
                        description: 'Pain in the kidney region',
                        associated_conditions: ['kidney_stones', 'pyelonephritis']
                    }
                }
            },
            conditions: {
                'kidney_stones': {
                    name: 'Kidney Stones',
                    properties: {
                        description: 'Hard deposits in the kidney',
                        severity: 'moderate to severe',
                        prevalence: 0.1
                    }
                },
                'urinary_tract_infection': {
                    name: 'Urinary Tract Infection',
                    properties: {
                        description: 'Bacterial infection of the urinary system',
                        severity: 'mild to moderate',
                        prevalence: 0.15
                    }
                }
            },
            treatments: {
                'pain_management': {
                    name: 'Pain Management',
                    properties: {
                        description: 'Comprehensive pain relief therapy',
                        efficacy: 0.85,
                        cost: 300,
                        side_effects: 0.15
                    }
                },
                'antibiotics': {
                    name: 'Antibiotic Therapy',
                    properties: {
                        description: 'Targeted antimicrobial treatment',
                        efficacy: 0.90,
                        cost: 150,
                        side_effects: 0.20
                    }
                }
            },
            relationships: {
                'kidney_stones': {
                    symptoms: ['hematuria', 'kidney_pain'],
                    treatments: ['pain_management', 'lithotripsy']
                },
                'urinary_tract_infection': {
                    symptoms: ['hematuria'],
                    treatments: ['antibiotics']
                }
            }
        };
    }

    async parseTextKB(text) {
        // Enhanced text parsing for biomedical knowledge
        const kb = {
            symptoms: {},
            conditions: {},
            treatments: {},
            relationships: {}
        };

        // Extract medical terms using regex patterns
        const medicalTerms = this.extractMedicalTermsFromText(text);
        
        // Process conditions
        medicalTerms.conditions.forEach(condition => {
            kb.conditions[condition.id] = {
                name: condition.name,
                properties: {
                    description: condition.context,
                    confidence: condition.confidence
                }
            };
        });

        // Process symptoms  
        medicalTerms.symptoms.forEach(symptom => {
            kb.symptoms[symptom.id] = {
                name: symptom.name,
                properties: {
                    description: symptom.context,
                    confidence: symptom.confidence
                }
            };
        });

        // Process treatments
        medicalTerms.treatments.forEach(treatment => {
            kb.treatments[treatment.id] = {
                name: treatment.name,
                properties: {
                    description: treatment.context,
                    confidence: treatment.confidence
                }
            };
        });

        // Merge with fallback to ensure minimum viable data
        const fallback = this.createFallbackKB();
        Object.assign(kb.conditions, fallback.conditions);
        Object.assign(kb.symptoms, fallback.symptoms);
        Object.assign(kb.treatments, fallback.treatments);
        Object.assign(kb.relationships, fallback.relationships);

        return kb;
    }

    extractMedicalTermsFromText(text) {
        const terms = {
            conditions: [],
            symptoms: [],
            treatments: []
        };

        // Medical condition patterns
        const conditionPatterns = [
            /\b(\w+)\s+(syndrome|disease|disorder|condition|cancer|tumor|infection|itis|osis)\b/gi,
            /\b(diabetes|hypertension|asthma|pneumonia|migraine|epilepsy)\b/gi
        ];

        // Symptom patterns
        const symptomPatterns = [
            /\b(pain|ache|headache|fever|nausea|fatigue|hematuria|dyspnea)\b/gi,
            /\b(\w+)\s+(pain|ache|bleeding)\b/gi
        ];

        // Treatment patterns
        const treatmentPatterns = [
            /\b(\w+)\s+(therapy|treatment|medication|surgery)\b/gi,
            /\b(antibiotics|analgesics|surgery|chemotherapy)\b/gi
        ];

        // Extract each type
        this.extractTermsByPatterns(text, conditionPatterns, terms.conditions, 'condition');
        this.extractTermsByPatterns(text, symptomPatterns, terms.symptoms, 'symptom');
        this.extractTermsByPatterns(text, treatmentPatterns, terms.treatments, 'treatment');

        return terms;
    }

    extractTermsByPatterns(text, patterns, termArray, type) {
        const found = new Set();
        
        patterns.forEach(pattern => {
            let match;
            pattern.lastIndex = 0;
            while ((match = pattern.exec(text)) !== null) {
                const term = match[0].toLowerCase().trim();
                if (term.length > 3 && !found.has(term)) {
                    found.add(term);
                    
                    const start = Math.max(0, match.index - 100);
                    const end = Math.min(text.length, match.index + match[0].length + 100);
                    const context = text.substring(start, end).trim();
                    
                    termArray.push({
                        id: term.replace(/\s+/g, '_').replace(/[^a-zA-Z0-9_]/g, ''),
                        name: term,
                        context: context,
                        confidence: 0.7,
                        type: type
                    });
                }
            }
        });
    }
}


        // Enhanced Clinical Display Components
        const ClinicalAnalysisResults = ({ analysis }) => {
            const [expandedNodes, setExpandedNodes] = React.useState(new Set(['root']));
            
            const toggleNode = (nodeId) => {
                const newExpanded = new Set(expandedNodes);
                if (newExpanded.has(nodeId)) {
                    newExpanded.delete(nodeId);
                } else {
                    newExpanded.add(nodeId);
                }
                setExpandedNodes(newExpanded);
            };

            const renderWorkflowNode = (node, level = 0) => {
                const isExpanded = expandedNodes.has(node.id);
                const nodeColors = {
                    symptom: 'bg-blue-100 border-blue-300',
                    diagnosis: 'bg-green-100 border-green-300',
                    treatment: 'bg-purple-100 border-purple-300',
                    outcome: 'bg-orange-100 border-orange-300'
                };
                
                const nodeIcons = {
                    symptom: <AlertCircle className="w-4 h-4" />,
                    diagnosis: <Brain className="w-4 h-4" />,
                    treatment: <Activity className="w-4 h-4" />,
                    outcome: <TrendingUp className="w-4 h-4" />
                };

                return (
                    <div key={node.id} style={{ marginLeft: `${level * 20}px` }}>
                        <div className={`p-3 rounded-lg border-2 ${nodeColors[node.type]} mb-2 cursor-pointer transition-all hover:shadow-md`}
                             onClick={() => toggleNode(node.id)}>
                            <div className="flex items-center gap-2">
                                {nodeIcons[node.type]}
                                <span className="font-medium">{node.title}</span>
                                {node.children && node.children.length > 0 && (
                                    <span className="text-xs bg-white px-2 py-1 rounded-full">
                                        {isExpanded ? '−' : '+'}
                                    </span>
                                )}
                            </div>
                            
                            {node.description && (
                                <p className="text-sm text-gray-600 mt-1">{node.description}</p>
                            )}
                            
                            {node.enhancedStatistics && (
                                <div className="mt-3 space-y-2">
                                    <div className="bg-white p-2 rounded border">
                                        <div className="flex items-center gap-1 text-sm font-medium text-green-600">
                                            <TrendingUp className="w-3 h-3" />
                                            Success: {(node.enhancedStatistics.success.mean * 100).toFixed(1)}% ± {(node.enhancedStatistics.success.se * 100).toFixed(1)}%
                                        </div>
                                    </div>
                                    
                                    <div className="bg-white p-2 rounded border">
                                        <div className="text-xs font-medium text-gray-700 mb-1">Comprehensive Costs</div>
                                        <div className="grid grid-cols-2 gap-1 text-xs">
                                            {Object.entries(node.enhancedStatistics.costBreakdown).map(([type, stats]) => (
                                                <div key={type} className="flex items-center gap-1">
                                                    {type === 'monetary' && <DollarSign className="w-3 h-3" />}
                                                    {type === 'pain' && <Thermometer className="w-3 h-3" />}
                                                    {type === 'emotional' && <Heart className="w-3 h-3" />}
                                                    {type === 'social' && <Users className="w-3 h-3" />}
                                                    {type === 'time' && <Clock className="w-3 h-3" />}
                                                    <span className="capitalize">{type}:</span>
                                                    <span>{stats.mean.toFixed(1)} ± {stats.se.toFixed(1)}</span>
                                                </div>
                                            ))}
                                        </div>
                                    </div>
                                </div>
                            )}
                            
                            {node.metadata && (
                                <div className="mt-2 text-xs text-gray-500">
                                    {node.metadata.severity && <div>Severity: {node.metadata.severity}</div>}
                                    {node.metadata.chronicityRisk && <div>Chronicity Risk: {(node.metadata.chronicityRisk * 100).toFixed(0)}%</div>}
                                    {node.metadata.evidenceLevel && <div>Evidence Level: {node.metadata.evidenceLevel}</div>}
                                </div>
                            )}
                        </div>
                        
                        {isExpanded && node.children && node.children.map(child => 
                            renderWorkflowNode(child, level + 1)
                        )}
                    </div>
                );
            };

            return (
                <div className="space-y-6">
                    {/* Clinical Summary */}
                    <div className="bg-white rounded-xl shadow-lg p-6">
                        <h2 className="text-xl font-semibold mb-4 flex items-center gap-2">
                            <Brain className="w-5 h-5 text-blue-600" />
                            Enhanced Clinical Analysis Summary
                        </h2>
                        
                        <div className="grid grid-cols-1 lg:grid-cols-2 gap-6">
                            <div className="bg-blue-50 p-4 rounded-lg">
                                <h3 className="font-medium text-blue-800 mb-2">Detected Symptoms</h3>
                                <div className="space-y-2">
                                    {analysis.symptoms.map((symptom, index) => (
                                        <div key={index} className="bg-blue-100 p-3 rounded text-sm">
                                            <div className="flex items-center justify-between">
                                                <span className="font-medium capitalize">
                                                    {symptom.severity !== 'moderate' && `${symptom.severity} `}
                                                    {symptom.temporal !== 'acute' && `${symptom.temporal} `}
                                                    {symptom.name}
                                                </span>
                                                <span className="text-xs bg-blue-200 px-2 py-1 rounded">
                                                    {(symptom.confidence * 100).toFixed(0)}%
                                                </span>
                                            </div>
{(symptom.hpoTerms || symptom.hpoId || symptom.synonyms) && (
    <div className="mt-1 text-xs text-blue-600">
        {symptom.hpoId && `HPO: ${symptom.hpoId}`}
        {symptom.hpoTerms && symptom.hpoTerms.length > 0 && ` | Terms: ${symptom.hpoTerms.join(', ')}`}
        {symptom.synonyms && symptom.synonyms.length > 0 && ` | Synonyms: ${symptom.synonyms.slice(0, 2).join(', ')}`}
        {symptom.matchedTerm && ` | Matched: "${symptom.matchedTerm}"`}
    </div>
)}
                                        </div>
                                    ))}
                                </div>
                            </div>
                            
                            <div className="bg-green-50 p-4 rounded-lg">
                                <h3 className="font-medium text-green-800 mb-2">Clinical Conditions</h3>
                                <div className="space-y-2">
                                    {analysis.conditions.map((condition, index) => (
                                        <div key={index} className="bg-green-100 p-3 rounded text-sm">
                                            <div className="flex items-center justify-between">
                                                <span className="font-medium">{condition.name}</span>
                                                <span className="text-xs bg-green-200 px-2 py-1 rounded">
                                                    {(condition.adjustedProbability * 100).toFixed(1)}%
                                                </span>
                                            </div>
                                            <div className="text-xs text-green-600 mt-1">
                                                {condition.prognosis}
                                            </div>
                                        </div>
                                    ))}
                                </div>
                            </div>
                        </div>
                        
                        <div className="mt-4 bg-purple-50 p-4 rounded-lg">
                            <h3 className="font-medium text-purple-800 mb-2">Analysis Quality</h3>
                            <div className="flex items-center gap-2">
                                <div className="flex-1 bg-gray-200 rounded-full h-3">
                                    <div 
                                        className="bg-purple-500 h-3 rounded-full transition-all duration-300"
                                        style={{ width: `${analysis.confidence * 100}%` }}
                                    ></div>
                                </div>
                                <span className="text-sm font-medium">
                                    {(analysis.confidence * 100).toFixed(1)}%
                                </span>
                            </div>
                        </div>
                    </div>
                    
                    {/* Clinical Workflow */}
                    {analysis.workflow && (
                        <div className="bg-white rounded-xl shadow-lg p-6">
                            <h2 className="text-xl font-semibold mb-4">Enhanced Clinical Decision Workflow</h2>
                            
                            <div className="bg-gradient-to-r from-blue-50 to-purple-50 p-4 rounded-lg mb-6">
                                <h3 className="font-semibold text-gray-800 mb-2">Comprehensive Cost Analysis</h3>
                                <div className="grid grid-cols-2 md:grid-cols-5 gap-3 text-xs">
                                    <div className="flex items-center gap-1">
                                        <DollarSign className="w-3 h-3 text-green-600" />
                                        <span><strong>Monetary:</strong> Direct costs</span>
                                    </div>
                                    <div className="flex items-center gap-1">
                                        <Thermometer className="w-3 h-3 text-red-600" />
                                        <span><strong>Pain:</strong> Physical discomfort</span>
                                    </div>
                                    <div className="flex items-center gap-1">
                                        <Heart className="w-3 h-3 text-pink-600" />
                                        <span><strong>Emotional:</strong> Psychological impact</span>
                                    </div>
                                    <div className="flex items-center gap-1">
                                        <Users className="w-3 h-3 text-blue-600" />
                                        <span><strong>Social:</strong> Relationship impact</span>
                                    </div>
                                    <div className="flex items-center gap-1">
                                        <Clock className="w-3 h-3 text-purple-600" />
                                        <span><strong>Time:</strong> Treatment duration</span>
                                    </div>
                                </div>
                            </div>
                            
                            <div className="max-h-96 overflow-y-auto">
                                {renderWorkflowNode(analysis.workflow)}
                            </div>
                        </div>
                    )}
                </div>
            );
        };

        // Main Application Component
        const ImprovedClinicalApp = () => {
            
// const [clinicalEngine] = React.useState(() => new ClinicalIntelligenceEngine());
const [clinicalEngine] = React.useState(() => new EnhancedClinicalIntelligenceEngine());
    

            const [isReady, setIsReady] = React.useState(false);
            const [userInput, setUserInput] = React.useState('');
            const [analysis, setAnalysis] = React.useState(null);
            const [isAnalyzing, setIsAnalyzing] = React.useState(false);
            const [analysisProgress, setAnalysisProgress] = React.useState(0);

            React.useEffect(() => {
                const checkReady = () => {
                    if (clinicalEngine.isReady) {
                        setIsReady(true);
                    } else {
                        setTimeout(checkReady, 100);
                    }
                };
                checkReady();
            }, [clinicalEngine]);

            const handleAnalysis = async () => {
                setIsAnalyzing(true);
                setAnalysisProgress(0);
                
                try {
                    const steps = [
                        'Initializing clinical analysis...',
                        'Detecting symptoms with HPO integration...',
                        'Analyzing clinical conditions...',
                        'Generating treatment pathways...',
                        'Running statistical simulations...',
                        'Synthesizing clinical workflow...'
                    ];
                    
                    for (let i = 0; i < steps.length; i++) {
                        setAnalysisProgress((i / steps.length) * 100);
                        await new Promise(resolve => setTimeout(resolve, 500));
                    }
                    
                    const result = await clinicalEngine.analyzeClinicalPresentation(userInput);
                    setAnalysis(result);
                    setAnalysisProgress(100);
                    
                } catch (error) {
                    console.error('Analysis error:', error);
                } finally {
                    setIsAnalyzing(false);
                }
            };

            const exportResults = () => {
                if (!analysis) return;
                
                const results = {
                    input: userInput,
                    analysis: analysis,
                    timestamp: new Date().toISOString(),
                    version: '2.0-Enhanced'
                };
                
                const blob = new Blob([JSON.stringify(results, null, 2)], { type: 'application/json' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `enhanced-clinical-analysis-${new Date().toISOString().split('T')[0]}.json`;
                a.click();
                URL.revokeObjectURL(url);
            };

            if (!isReady) {
                return (
                    <div className="min-h-screen bg-gradient-to-br from-blue-50 to-indigo-100 flex items-center justify-center">
                        <div className="bg-white rounded-xl shadow-lg p-8 max-w-md mx-auto">
                            <div className="text-center">
                                <div className="loading-spinner mx-auto mb-4"></div>
                                <h2 className="text-xl font-semibold mb-2">Initializing Clinical Engine</h2>
                                <p className="text-gray-600">Loading enhanced knowledge bases...</p>
                            </div>
                        </div>
                    </div>
                );
            }

            return (
                <div className="min-h-screen bg-gradient-to-br from-blue-50 to-indigo-100">
                    {/* Header */}
                    <nav className="bg-white shadow-lg border-b-4 border-blue-600">
                        <div className="max-w-7xl mx-auto px-6 py-4">
                            <div className="flex items-center justify-between">
                                <div className="flex items-center space-x-4">
                                    <div className="w-12 h-12 flex items-center justify-center">
                                        <img src="SOCR_Logo.png" alt="SOCR Logo" className="w-12 h-12 object-contain" />
                                    </div>
                                    <div>
                                        <h1 className="text-2xl font-bold text-gray-800">CLNQ: AI Clinical Decision Support (Gen-2)</h1>
                                        <p className="text-sm text-gray-600">SOCR AI Clinical Decision Support Platform (Enhanced Gen-1)</p>
                                    </div>
                                </div>
                                <div className="flex items-center space-x-6">
                                    <div className="flex items-center gap-2">
                                        <Database className="w-4 h-4 text-green-500" />
                                        <span className="text-sm text-green-600">Enhanced HPO & Biomedical Knowledgebase Engine</span>
                                    </div>
                                    <a href="https://www.socr.umich.edu/" target="_blank" rel="noopener noreferrer" 
                                       className="text-blue-600 hover:text-blue-800 transition-colors">
                                        Visit SOCR.umich.edu
                                    </a>
									<div className="text-blue-600 hover:text-blue-800 transition-colors">
                       					<a href="https://www.socr.umich.edu/GAIM" target="_blank" rel="noopener noreferrer" 
                        					className="text-blue-600 hover:text-blue-800 transition-colors">Other SOCR GAIM Platforms</a>
                     				</div>
                                </div>
                            </div>
                        </div>
                    </nav>

                    <div className="p-6">
                        <div className="max-w-7xl mx-auto">
                            {/* Introduction */}
                            <div className="bg-white rounded-xl shadow-lg p-6 mb-6">
                                <h1 className="text-3xl font-bold text-gray-800 mb-2">
                                    Enhanced Clinical Decision Support System
                                </h1>
                                <p className="text-gray-600 mb-4">
                                    Extending CLNQ Gen-1 with Gen-2 Knowledge Depth for Optimal Clinical Insights
                                </p>
                                <div className="flex gap-2 mb-4 text-sm">
                                    <span className="bg-blue-100 text-blue-800 px-3 py-1 rounded-full">V.1 Clinical Coherence</span>
                                    <span className="bg-green-100 text-green-800 px-3 py-1 rounded-full">HPO Integration</span>
                                    <span className="bg-purple-100 text-purple-800 px-3 py-1 rounded-full">Enhanced Knowledge Base</span>
                                    <span className="bg-orange-100 text-orange-800 px-3 py-1 rounded-full">Statistical Modeling</span>
                                </div>
                            </div>

                            {/* Input Section */}
                            <div className="bg-white rounded-xl shadow-lg p-6 mb-6">
                                <h2 className="text-xl font-semibold mb-4">Clinical Presentation Analysis</h2>
                                <textarea
                                    value={userInput}
                                    onChange={(e) => setUserInput(e.target.value)}
                                    placeholder="Describe the clinical presentation. Example: 'Patient presents with severe, throbbing headaches occurring every morning for the past 2 weeks, accompanied by nausea and sensitivity to light. The headaches are interfering with daily activities.'"
                                    className="w-full h-32 p-4 border border-gray-300 rounded-lg resize-none focus:outline-none focus:ring-2 focus:ring-blue-500"
                                />
                                <div className="flex gap-4 mt-4">
                                    <button
                                        onClick={handleAnalysis}
                                        disabled={!userInput.trim() || isAnalyzing}
                                        className="flex items-center gap-2 bg-blue-600 text-white px-6 py-3 rounded-lg hover:bg-blue-700 disabled:opacity-50 disabled:cursor-not-allowed transition-colors"
                                    >
                                        {isAnalyzing ? <Pause className="w-4 h-4" /> : <Play className="w-4 h-4" />}
                                        {isAnalyzing ? 'Analyzing...' : 'Enhanced Clinical Analysis'}
                                    </button>
                                    {analysis && (
                                        <button
                                            onClick={exportResults}
                                            className="flex items-center gap-2 bg-green-600 text-white px-6 py-3 rounded-lg hover:bg-green-700 transition-colors"
                                        >
                                            <Download className="w-4 h-4" />
                                            Export Results
                                        </button>
                                    )}
                                </div>
                                
                                {isAnalyzing && (
                                    <div className="mt-4">
                                        <div className="bg-gray-200 rounded-full h-3">
                                            <div 
                                                className="bg-blue-600 h-3 rounded-full transition-all duration-500"
                                                style={{ width: `${analysisProgress}%` }}
                                            ></div>
                                        </div>
                                        <p className="text-sm text-gray-600 mt-2">
                                            Running enhanced clinical analysis with HPO integration and statistical modeling...
                                        </p>
                                    </div>
                                )}
                            </div>

                            {/* Results */}
                            {analysis && (
                                <ClinicalAnalysisResults analysis={analysis} />
                            )}
                        </div>
                    </div>

                    {/* Footer */}
                    <footer className="bg-gray-800 text-white mt-12">
                        <div className="max-w-7xl mx-auto px-6 py-8">
                            <div className="grid grid-cols-1 md:grid-cols-3 gap-8">
                                <div>
                                    <div className="flex items-center space-x-3 mb-4">
                                        <div className="w-12 h-12 flex items-center justify-center">
                                            <img src="SOCR_Logo.png" alt="SOCR Logo" className="w-12 h-12 object-contain" />
                                        </div>
                                        <div>
                                            <h3 className="text-lg font-semibold">SOCR Enhanced Clinical AI</h3>
                                            <p className="text-sm text-gray-300">V.2 with Clinical Coherence</p>
                                        </div>
                                    </div>
                                    <p className="text-gray-300 text-sm">
                                        Extending CLNQ Gen-1 clinical clarity with Gen-2 knowledge depth.
                                    </p>

					<ul className="space-y-2 text-sm">
                       <li>
                         <a href="https://socr.umich.edu/GAIM/SOCR_CLNQ_0.html" className="text-blue-400 hover:text-blue-300 transition-colors">
                           CLNQ Gen-0</a>
                       </li>
                       <li>
                         <a href="https://socr.umich.edu/GAIM/SOCR_CLNQ_1.html" className="text-blue-400 hover:text-blue-300 transition-colors">
                           CLNQ Gen-1</a>
                       </li>
                       <li>
                         <a href="https://clinique.statisticalcomputing.org/" className="text-blue-400 hover:text-blue-300 transition-colors">
                           CLNQ Gen-3</a>
                       </li>
                       <li>
                         <a href="https://clnq.statisticalcomputing.org/" className="text-blue-400 hover:text-blue-300 transition-colors">
                           CLNQ Gen-4</a>
                       </li>
                     </ul>
                                </div>
                                
                                <div>
                                    <h4 className="text-lg font-semibold mb-4">Enhanced Features</h4>
                                    <ul className="space-y-2 text-sm text-gray-300">
                                        <li>• Clinical Intelligence Engine</li>
                                        <li>• HPO Ontology Integration</li>
                                        <li>• Statistical Treatment Modeling</li>
                                        <li>• Comprehensive Cost Analysis</li>
                                        <li>• Evidence-Based Recommendations</li>
                                    </ul>
                                </div>
                                
                                <div>
                                    <h4 className="text-lg font-semibold mb-4">Resources</h4>
                                    <ul className="space-y-2 text-sm">
                                        <li>
                                            <a href="https://www.socr.umich.edu/" className="text-blue-400 hover:text-blue-300 transition-colors">
                                                SOCR Main Site
                                            </a>
                                        </li>
                                        <li>
                                            <a href="https://hpo.jax.org/" className="text-blue-400 hover:text-blue-300 transition-colors">
                                                HPO Ontology
                                            </a>
                                        </li>
                                        <li>
                                            <a href="https://github.com/SOCR" className="text-blue-400 hover:text-blue-300 transition-colors">
                                                GitHub Repository
                                            </a>
                                        </li>
                                    </ul>
                                </div>
                            </div>
                            
                            <div className="border-t border-gray-700 mt-8 pt-6 flex flex-col md:flex-row justify-between items-center">
                                <div className="text-sm text-gray-400">
                                    © 2025 SOCR - University of Michigan. Enhanced Clinical AI v2.0
                                </div>
                                <div className="text-sm text-gray-400 mt-2 md:mt-0">
                                    <strong>Clinical Disclaimer:</strong> For educational and research purposes only. Always consult healthcare professionals.
                                </div>
                            </div>
                        </div>
                    </footer>
                </div>
            );
        };

        const root = ReactDOM.createRoot(document.getElementById('root'));
        root.render(<ImprovedClinicalApp />);
    </script>

    <!-- Start of StatCounter Code -->
    <script type="text/javascript">
        var sc_project = 5714596;
        var sc_invisible = 1;
        var sc_security = "038e9ac4";
        var scJsHost = (("https:" == document.location.protocol) ? "https://secure."
                : "https://www.");
        document
                .write("<sc"+"ript type='text/javascript' src='" +
        scJsHost+
        "statcounter.com/counter/counter.js'></"+"script>");
    </script>
    <noscript>
        <div class="statcounter">
            <a title="web analytics" href="https://statcounter.com/"
                target="_blank"><img class="statcounter"
                src="//c.statcounter.com/5714596/0/038e9ac4/1/"
                alt="web analytics"></a>
        </div>
    </noscript>
    <!-- End of StatCounter Code -->

    <!-- GoogleAnalytics -->
    <script src="https://www.google-analytics.com/urchin.js" type="text/javascript"> </script>
    <script type="text/javascript"> _uacct = "UA-676559-1"; urchinTracker(); </script>
    
    <!-- Global site tag (gtag.js) - Google Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-69710121-1"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());

      gtag('config', 'UA-69710121-1');
    </script>
    <!-- End of GoogleAnalytics Code -->

</body>
</html>